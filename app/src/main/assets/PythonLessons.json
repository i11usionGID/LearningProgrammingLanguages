[
    {
      "id": 1,
      "language":"Python",
      "title": "Урок 1. Обзор языка Python.",
      "text": "Python — простой язык программирования с лаконичным и понятным синтаксисом.\nОбычно программы состоят из множества строк, в которых записаны команды на языке Python. Команды выполняются последовательно, строка за строкой, и в результате программа решает свою задачу.\nПеред вами простая программа, состоящая из одной команды на Python: import this.\nПопробуйте запустить программу в любом онлайн компиляторе.\nЭто не обыкновенная команда, а секрет от разработчиков: она выводит на экран «Дзен Питона».\n\nimport this\n\nКак вы думаете, что делает это программа?\nname = 'Ваня'\n\nПервая команда: «положить в переменную name слово \"Ваня\"». Программист мог записать в эту переменную любое имя или слово.\nВторая команда: «напечатать на экран сообщение \"Меня зовут\" и то слово, которое хранится в переменной name».\nПрограммирование — это процесс написания таких вот команд. Разработчик пишет их, потом нажимает кнопку, и компьютер их выполняет. Вот и вся магия.\nprint('Меня зовут', name)",
      "isLock": false
    },
    {
      "id": 2,
      "language": "Python",
      "title": "Урок 2. Первый код.",
      "text": "Пора начинать работу. Самая простая операция в Python — это вывод данных на экран. Запустите код в онлайн компиляторе.\n\n/////////////////////\nprint('Привет, Мир!')\n/////////////////////\n\nПрограмма вывела на экран сообщение «Привет, Мир!»: Python прочитал код, увидел в нём функцию print() и выполнил её.\nФункция — это подпрограмма, выполняющая определённые действия. Функция print() — это встроенная в Python подпрограмма для вывода данных на экран.\n'Привет, Мир!' — это текст, который функция print() напечатает. Функция print() выводит на экран любые данные, указанные в скобках после названия функции.\nПрограммисты называют такие данные «аргументы»; аргументы указывают в скобках после имени функции.\nВ аргументе функции print() в коде программы, которую вы только что запускали.\n\nГоворят, что аргумент передаётся в функцию, а функция их принимает. Python выполняет код, читая строку за строкой;\nувидев в коде имя функции с круглыми скобками, Python вызывает эту функцию — заставляет сработать код этой функции. При необходимости функцию можно вызывать много раз.\nЗапустите код в онлайн компиляторе.\nPython прочтёт код сверху вниз и выполнит все инструкции, которые увидит.\n\n/////////////////////////\nprint('Привет, Мир!')\nprint('Я тебя люблю!')\n/////////////////////////\n\nКод для людей: комментарии\nСтроки, начинающиеся с символа # — это комментарии, примечания, которые автор программы пишет для других разработчиков.\nPython игнорирует любые символы на строчке после #. Обратите внимание, что комментарии автоматически выделяются цветом в компиляторе, это упрощает чтение.\nЕсли символом комментария скрыть часть кода — Python перестанет видеть этот код и не станет его выполнять.\nТекст комментариев предназначен не программе, а человеку, читающему код. Читайте комментарии, в них будут полезные инструкции.\n\n/////////////////////////////////////////////////////////////////////////////\n# Приветствие миру — традиционная первая строка в освоении нового языка,\n# но что-то пошло не так.\n# Ниже написан вызов функции print() с аргументом 'Пока, Мир!'\n# Замените \"Пока\" на \"Привет\",\nprint('Пока, Мир!')\n/////////////////////////////////////////////////////////////////////////////\n\nЗадание 1\nСейчас код закоментирован. Перенесите его в онлайн компилятор и попробуйте сделать так, чтобы Python увидел и выполнил код.\nДля этого уберите символ комментария и пробел в начале строки (это называют «раскомментировать» строку).\n\n/////////////////////////////////\n# print('Ура, теперь меня видно!')\n/////////////////////////////////\n\nЗадание 2\nПопробуйте самостоятельно сделать так, чтобы вывелась еще одна строчка.\nПосле строки print('Ура, теперь меня видно!') добавьте новую строку кода, которая напечатает текст 'Спасибо большое!'. \n\n////////////////////////////////\nprint('Ура, теперь меня видно!')\n/////////////////////////////////",
      "isLock": true
    },
    {
      "id": 3,
      "language": "Python",
      "title": "Урок 3. Переменные и типы.",
      "text": "Отлично, вы научились выводить строки на экран. Но просто напечатать строку — этого мало.\nПредставьте: вы читаете книгу, но не можете запомнить, сколько страниц прочли. Умеете читать,\nно вот сохранить в памяти номер страницы не удаётся. Вылетает из головы, где вы остановились,\nпоэтому приходится отсчитывать страницы от начала книги. 10, 24, 140, 250 страниц — и так каждый раз.\nТак же беспомощны программы, которые не могут сохранять данные. Именно поэтому настоящее программирование начинается с переменных,\nзапоминающих результаты промежуточных действий.\nПеременная работает как подписанная коробка или помеченная ячейка, куда можно что-то положить и не потерять.\nКогда в коде впервые пишут имя переменной, это называется объявление переменной. Имя придумывает сам программист.\nВ Python переменную объявляют, присваивая ей какое-нибудь значение. Для объявления переменной достаточно просто\nуказать имя, поставить знак «равно» = (этот знак в Питоне называется оператор присваивания) и написать значение, которое будет храниться в переменной.\nСмысл оператора присваивания = отличается от того, к которому вы привыкли. В программировании выражение x = 1 означает: «теперь в переменной x хранится значение 1».\nПосле того как переменной присвоено какое-то значение, его можно заменить: для этого нужно присвоить этой переменной другое значение: x = 38.\nТеперь в переменной x хранится не единица, а число 38.\nВернёмся к чтению. Отложив программирование и ночной сон, вы прочли 210 страниц. Теперь можно написать так:\n\n\\\\\\\\\\\\npages = 210\n\\\\\\\\\\\\n\nЗдесь создана переменная с именем pages, в этой переменной сохранено значение 210.\nВ переменных можно сохранить не только числа: в них можно «положить» и строку. Например, строка 'Привет, Мир!' — это другой пример данных, которые могут храниться в переменной.\nНапример, вот так:\n\n\\\\\\\\\\\\\\\\\\\\\\\\nmessage = 'Привет, Мир!'\n\\\\\\\\\\\\\\\\\\\\\\\\n\nА теперь следующий шаг: когда переменная объявлена и ей присвоено значение — имя этой переменной можно указывать в коде, и вместо имени будет подставляться её значение.\nПоэкспериментируйте:\n1. Запустите код в онлайн компиляторе, в нём в функцию print() передана переменная message.\n2. Замените фразу 'Привет, Мир!' на какую-нибудь другую и запустите код ещё раз.\n\n////////////////////////////////////////////////////////////////////\nmessage = 'Привет, Мир!'\n# В функцию передан не текст, а переменная, в которой хранится текст:\nprint(message)\n////////////////////////////////////////////////////////////////////\n\nТеперь в переменную message можно сохранить любое значение — и оно будет напечатано.\n\nЗадача 1\nПопробуйте напечатать на экран свое имя и свой возраст, например, вот так:\n'Привет, я Ваня, мне 20 лет!'\nДля этого в переменные name и age подставьте свои данные, а также вместо многоточий укажите правильные переменные.\n\n////////////////////////////////////////////////////\nname = 'Ваня'                 # Имя\nage = '20'#                 Возраст\n# Подставьте имена переменных вместо многоточий\nprint('Привет, я ' + ... + ', мне ' + ... + ' лет!')\n/////////////////////////////////////////////////////",
      "isLock": true
    },
    {
      "id": 4,
      "language": "Python",
      "title": "Урок 4. Типы данных: числа и строки.",
      "text": "Значения переменных различаются по своей сути: например, значения могут быть числами или строками.\nЭто разные типы данных. В Python есть и другие типы, но пока хватит и этих двух.\nСтрока записывается как символ или набор символов внутри 'одинарных' либо \"двойных\" кавычек.\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nname = 'Война и мир'  # Строка в одинарных кавычках\nauthor = \"Лев Николаевич Толсто́й\"  # Строка в двойных кавычках\npages = '1300'  # Число в кавычках тоже становится строкой\nspace = ' ' # Даже пробел — это тоже строка\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nДля обрамления строк можно пользоваться одинарными или двойными кавычками, но главное — открывающая и закрывающая кавычки должны быть одинаковыми.\nПрименение разных кавычек в начале и конце строки приведёт к ошибке.\nПопробуйте запустить программу в онлайн компиляторе:\n\n//////////////////////////////////////////////////////////\n# Такой код сломает программу:\n# открывающие и закрывающие кавычки должны быть одинаковыми\nauthor = \"Лев Николаевич Толсто́й'\n//////////////////////////////////////////////////////////\n\nЧисловые значения записываются без кавычек:\n\n\\\\\\\\\\\\\\\\\\n\n twenty_one = 21\nabout_pi = 3\n\n\\\\\\\\\\\\\\\\\\n\nОбратите внимание: в редакторе кода или онлайн компиляторе числа и строки выделяются разными цветами, чтобы читать исходный код было легче.\nВы можете спросить, а в чем разница?\nСо значениями разных типов Python работает по-разному.\nС переменными, которые содержат числа, можно проводить любые арифметические операции: например, складывать их при помощи оператора +:\n\n///////////////////////////////////////////////////////\n twenty_one = 21\nabout_pi = 3\n# Переменные одного типа можно складывать,\n# а получившееся значение присваивать другой переменной\ntotal = twenty_one + about_pi\n# Напечатаем эту переменную:\nprint(total)\n////////////////////////////////////////////////////////\n\nЭто уже почти калькулятор!\nНо если те же значения переменных записать как строки (взять значения в кавычки) — результат изменится.\nЗапустите код в онлайн компиляторе: как вам такая «арифметика»?\n\n/////////////////////////////\n twenty_one = '21'\nabout_pi = '3'\ntotal = twenty_one + about_pi\nprint(total)\n/////////////////////////////\n\nСо строками всё происходит не так, как с числами: при сложении двух строк Python «склеивает» содержимое этих строк в одну.\n\nТочно так же будет работать и сложение переменных, если в этих переменных хранятся строки:\n\n////////////////////////////////////////////////////////////////////////\n# В четырёх переменных содержатся строки:\nword1 = 'Символы '\nword2 = 'в кавычках — '\nword3 = 'это '\nword4 = 'строки.'\n# Можно сложить эти переменные, а результат сохранить в переменную text\ntext = word1 + word2 + word3 + word4\n# ...а переменную text можно напечатать\nprint(text)\n////////////////////////////////////////////////////////////////////////\n\nОбъединение нескольких строк в одну называют «конкатенацией» (от лат. concatenatio, «присоединение, сцепление»).\nА вот сложить число и строку так просто не удастся: складывать можно значения одинакового типа, иначе Python выдаст ошибку.\n\n/////////////////////////////////////////////////////////\n num_as_string = '999'  # Значение этой переменной — строка\nnum_as_num = 1  # Значение этой переменной — число\n# Попробуем сложить и напечатать:\nprint(num_as_string + num_as_num)\n/////////////////////////////////////////////////////////\n\nВсё сломалось!\n\nЗадание\nПопробуйте дописать программу фитнес-трекер, которая подсчитывает количество шагов, сделанных пользователем, и сообщит ему результат.\nВ переменных steps_today и steps_yesterday записано, сколько шагов прошёл Шурик вчера и сегодня.\nВычислите в коде сумму шагов за два дня и сохраните результат в переменную steps_sum. А программа напечатает получившийся результат.\n\n/////////////////////////////////////////////////////////////\n steps_yesterday = 15327\nsteps_today = 8933\n# Вычислите сумму здесь: вместо многоточия напишите выражение,\n# суммирующее количество шагов за два дня\nsteps_sum = ...  \nprint('Сколько шагов сделал Шурик за два дня?')\nprint(steps_sum)\n//////////////////////////////////////////////////////////////",
      "isLock": true
    },
    {
      "id": 5,
      "language": "Python",
      "title": "Урок 5. Преобразование типов.",
      "text": "Со значениями разных типов операторы языка Python работают по-разному, вы это видели:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\none_hundred = 100\nfive_hundred = 500\nprint(one_hundred + five_hundred)\n# Будет напечатано: 600\na = 'ха'\nprint(a + a + a + a)\n# Будет напечатано: хахахаха \n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nСтроку можно умножить на целое число (оператор умножения — звёздочка *). Запустите этот код в онлайн компиляторе и посмотрите, что получится.\n\n////////////////////////////////////////////////////////////////\n# Если умножить число на число - никаких неожиданностей не будет\ntwo = 2\nprint(two * 3)\n# А умножение строки на число скопирует строку несколько раз\ncow = 'му'\nprint(cow * 3)\n////////////////////////////////////////////////////////////////\n\nТакое поведение операторов приходится учитывать.\nТакой код не сработает, Python выдаст ошибку:\n\n//////////////////////////////////////////////////////////////////////////////////////\n# Объявили две переменные разных типов\nnumber = 10\napples = ' яблок'\nprint(number + apples)\n# В тексте ошибки будет сказано, что оператор '+' не складывает целые числа со строками\n//////////////////////////////////////////////////////////////////////////////////////\n\nНе беда: Python позволяет перевести значение переменной из одного типа в другой (конвертировать тип данных; иначе говорят «привести к типу»).\nПреобразованием данных из одного типа в другой занимаются специальные функции. Так, для превращения числа в строку вызывают функцию str():\n\n/////////////////////////////////////////////////////////////////////////////////\n# Код, где число преобразовано в строку (\"приведено к строке\"), прекрасно работает\nnumber = 10\napples = ' яблок'\nprint(str(number) + apples)\n/////////////////////////////////////////////////////////////////////////////////\n\nА преобразовать строку в целое число можно функцией int().\n\n//////////////////////////////////////////////////////////////////////////////////\nЕсли сложить строки (они в кавычках!) '100' и '500' — ничего хорошего не получится:\none_hundred = '100'\nfive_hundred = '500'\nprint(one_hundred + five_hundred)\n# Будет напечатано: 100500  \n# стопятьсот? Не то. \n//////////////////////////////////////////////////////////////////////////////////\n\nПреобразуем строки в числа и сложим:\n\n//////////////////////////////////////////\none_hundred = '100'\nfive_hundred = '500'\nprint(int(one_hundred) + int(five_hundred))\n//////////////////////////////////////////\n\nТак-то лучше!\n\nЗадание\nПопробуйте дописать программу, которая информирует о том, сколько у вас сообщений.\nВыведите на экран строку 'У вас 8 новых сообщений', составленную из строки 'У вас ', значения переменной count и из строки ' новых сообщений'.\n\n////////////////////////////////////////////////////////////\ncount = 8\nmessage = 'У вас ' + str(...) + ...  # Допишите ваш код здесь\nprint(message)\n/////////////////////////////////////////////////////////////",
      "isLock": true
    },
    {
      "id": 6,
      "language": "Python",
      "title": "Урок 6. Ошибки.",
      "text": "Изучение новой области знаний всегда начинается с проб и ошибок (взять хотя бы искусство кулинарии). Разработка — не исключение: во время обучения вы постоянно будете делать ошибки в коде. И на протяжении всей своей карьеры разработчика вы тоже будете делать ошибки. Написать код, а затем отловить и исправить баги — это стандартный путь программиста. Это норма!\n\nPython изо всех сил постарается помочь вам найти ошибку, предоставляя всю возможную информацию о проблеме: «Я сломался, ошибка на строке 8, там забыли закрыть скобку!» Разговаривает Python по-английски, но понять его несложно, даже если у вас нет глубоких познаний в языке. Читайте всё, что он пишет: это поможет самостоятельно разобраться с ошибкой. Сообщения об ошибках называются traceback (по-русски говорят «трейсбэк»).\n\nВозможно, вы уже делали ошибки в предыдущих заданиях. В этом уроке мы будем делать их осознанно.\n\nОшибка «неизвестное имя»\nЗапустите код в онлайн компиляторе и посмотрите, что вам ответит Python. Во второй строке допущена опечатка: в имени переменной пропущено подчёркивание. Python споткнулся о неизвестное имя переменной и выдал сообщение об ошибке, указав детали:\n• в какой строчке кода обнаружена ошибка: line 2;\n• тип ошибки: NameError;\n• из-за чего произошла ошибка: name 'onehundred' is not defined (никаких сущностей с именем onehundred ещё не объявлялось).\nПоправьте опечатку и запустите код вновь.\n\n/////////////////\none_hundred = 100\nprint(onehundred)\n/////////////////\n\nОшибки синтаксиса\nПосмотрите внимательно на код и запустите его в онлайн компиляторе. В результате вы получите сообщение SyntaxError, «ошибка синтаксиса»: при сложении забыли написать одно слагаемое. Сообщение invalid syntax переводится как «недопустимый синтаксис». Поправьте ошибку — прибавьте к тройке любое число и запустите код.\n\n//////////\nprint(3 + )\n//////////\n\nДругую разновидность ошибки SyntaxError можно получить, если забыть скобку или кавычку. Выполните этот кривой код в онлайн компиляторе и прочтите ответ Питона.\n\n//////////\nprint(3 + 5\n//////////\n\nВ тексте SyntaxError: unexpected EOF while parsing сокращение EOF означает end of file, а само сообщение переводится как «неожиданный конец файла во время разбора кода программы»: Python увидел начало вызова функции, но внезапно код программы закончился. Поправьте код и запустите его вновь.\n\nА теперь попробуйте запустить другой код: в первой строке допущена ошибка, а во второй — всё ок. Обратите внимание, на какую строку укажет сообщение об ошибке.\n\n/////////////////////\nprint(3 + 5\nprint('Всё в порядке!')\n/////////////////////\n\nДело в том, что Python разрешает ставить открывающую и закрывающую скобки на разных строчках. Поэтому он терпеливо дожидается, пока код совершенно утратит смысл, и только тогда выдаёт ошибку.\n\nЭтот код показал и ещё одну особенность поведения Python: при любой ошибке выполнение кода полностью останавливается; код, написанный после строки с ошибкой, не будет выполнен, будь он даже самый распрекрасный и правильный. Поправьте ошибку, запустите код — и двигайтесь дальше, к новым ошибкам.\n\nТеперь напечатаем девиз разработчика. Выполните этот код:\n\n/////////////////\nprint('Лови баги!)\n/////////////////\n\nОпять ошибка: SyntaxError: EOL while scanning string literal; сокращение EOL означает end of line, а полный текст сообщения переводится как «конец строки во время обработки текста». Python увидел открывающую кавычку, но строчка закончилась, а закрывающей кавычки не было. На этом Python сломался. Поставьте кавычку после строки (обязательно одинарную — ведь в начале строки Лови баги! стоит одинарная кавычка) и повторно запустите код.\n\nОшибка в типах данных\nПростая, на первый взгляд, задача: сложить значения двух переменных. Запустите код — и немедленно “something went wrong”.\n\nПопытка сложить число 100 и строку '500' (любые символы, замкнутые в кавычки, — это «строка») приводит к ошибке: складывать строки и числа нельзя. Python так и напишет:\nTypeError: unsupported operand type(s) for +: 'int' and 'str'.\n\nИсправьте ошибку — запишите значение переменной five_hundred в виде числа (уберите кавычки): five_hundred = 500. Но правильнее всего будет привести значение переменной five_hundred к числу через функцию int().\n\nРезультатом работы программы будет число 600.\n\n//////////////////////////////////////////////////////\none_hundred = 100\nfive_hundred = '500'\nprint('В ответе можно получить 600, а можно и 100500!')\nprint(one_hundred + five_hundred)\nprint('Вот мы и получили 600')\n//////////////////////////////////////////////////////\n\nЭту же задачу можно решить иначе: если записать значение переменной one_hundred в виде строки — one_hundred = '100', то в коде будут складываться две строки и результатом работы программы будет строка '100500'.\n\nПривести значение переменной к строке можно и с помощью функции str(): в уроке «Преобразование типов» вы уже делали это.\n\nВ выражении one_hundred + five_hundred приведите переменную one_hundred к правильному типу данных так, чтобы в результате программа напечатала строку '100500'. Не изменяйте первые две строки, где переменным присваиваются значения.\n\n//////////////////////////////////////////////////////\none_hundred = 100\nfive_hundred = '500'\nprint('В ответе можно получить 600, а можно и 100500!')\nprint(one_hundred + five_hundred)\nprint('Вот мы и получили 100500')\n///////////////////////////////////////////////////////",
      "isLock": true
    },
    {
      "id": 7,
      "language": "Python",
      "title": "Урок 7. Именование переменных.",
      "text": "В именах переменных используйте только латинский алфавит, цифры и подчеркивание. Остальные символы, в том числе буквы кириллицы, могут привести к ошибкам. Они создают путаницу: например, английская x и русская х выглядят одинаково.\n\nЕсли название состоит из нескольких слов, разделяйте их символом подчёркивания: new_message. Такой стиль написания называется snake case, потому что слова могут получаться очень_длинные_как_змея_или_даже_как_две.\n\nPython допускает использование цифр в именах переменных, но не на первой позиции:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nsnake1 = \"питон\"\nsnake2 = \"удав\"\nlong_snake = \"длинный змей\"\nprint(long_snake + \" — это может быть \" + snake1 + \" или \" + snake2)\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nПолучится:\nдлинный змей — это может быть питон или удав\n\nВажно\nКак выбрать имя переменной?\nСоставляйте названия переменных из английских слов. Когда ваша программа вырастет до многих сотен строк, названия-слова помогут быстро сориентироваться в коде.\n\nСравните сами: переменную с названием урока можно назвать буквой l, а можно — словом lesson. Второй вариант лучше: ведь то, что когда-то разработчик сократил lesson до одной буквы, со временем забудут и он, и его коллеги. Код станет сложнее для чтения.\n\nНе рекомендуется использовать русские слова в английской раскладке. Рано или поздно ваш код будет читать человек, не владеющий русским. Он может не понять, что к чему. Сразу называйте переменные по-английски: child, а не транслитерацией — rebyonok.",
      "isLock": true
    },
    {
      "id": 8,
      "language": "Python",
      "title": "Урок 8. Вывод на экран.",
      "text": "Вы уже умеете выводить на экран текст, складывая строки. Но можно напечатать и без оператора +: в скобках функции print() перечислите через запятую аргументы, которые она должна напечатать:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nweather = 'солнечно'\nprint('На улице сейчас', weather)\n# Будет напечатано:\n# На улице сейчас солнечно\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nЗапятая между аргументами по умолчанию заменяется на пробел.\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nprint('За', 'окном', 'дождь')\n# Будет напечатано:\n# За окном дождь\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nЭто значит, что в сообщения программы можно не добавлять пробелы, когда вы составляете сложную фразу. Достаточно разделить аргументы функции print() запятой. И, что приятно, количество этих аргументов не ограничено:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ncurrent_hour = 10\nmessages_count = 15\nprint('К', current_hour, 'ч.', 'у тебя накопилось', messages_count, 'новых сообщений.')\n# Будет напечатано:\n# К 10 ч. у тебя накопилось 15 новых сообщений.\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nНеожиданно обнаружилось ещё одно приятное свойство функции print(): посмотрите на код, там через запятую перечислены и строки, и числа, и все они печатаются без проблем. А ведь если бы мы захотели сначала подготовить полную строку для печати, а потом передать её в функцию print() — нам пришлось бы преобразовывать число в строку:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nmessages_count = 100500\n# Складывать строки и числа нельзя,\n# потому придётся преобразовать messages_count в строку:\nhow_many_messages = 'У тебя ' + str(messages_count) + ' новых сообщений.'\nprint(how_many_messages)\n# Будет напечатано:\n# У тебя 100500 новых сообщений.\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/",
      "isLock": true
    },
    {
      "id": 9,
      "language": "Python",
      "title": "Урок 9. Дробные числа.",
      "text": "Числа бывают целыми и дробными. Для десятичных дробей (иначе их называют «числа с плавающей запятой») в Python есть специальный тип данных — float.\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfirst = 10.2\nsecond = 20.2\nthird = 30.242\nprint(first + second + third)\n# Будет напечатано: 60.642 \n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nДробные числа преобразуют в строки так же, как и целые — функцией str():\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfirst = 10.2\nsecond = 20.2\nthird = 30.242\nprint(str(first) + str(second) + str(third))\n# Будет напечатано: 10.220.230.242 \n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nТакой похожий код — и такой разный результат! Можно преобразовать строку в дробное число, для этого есть функция float():\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfirst = '10.2'   # Строка\nsecond = '20.2'  # Тоже строка\nthird = '30.242' # И это строка\nprint(float(first) + float(second) + float(third)) # А в итоге получится число!\n# Будет напечатано: 60.642 \n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nДробные числа приводят к целым функцией int(). Обратите внимание: int() не округляет числа по правилам арифметики, а просто отбрасывает дробную часть.\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n# Функция int() просто убирает всё, что после запятой. Вместе с запятой:\na = int(3.14)\nprint(a)\n# Будет напечатано: 3 \n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\n/a = int(2.72)\nprint(a)\n# Будет напечатано: 2 \n\\\\\\\\\\\\\\\\\\\\\\\\\\\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n# Функция int() одинаково работает с положительными и отрицательными числами\n/a = int(-3.14)\nprint(a)\n# Будет напечатано: -3 \n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nМожно сделать несколько преобразований в одной строке: сначала превратить дробь в целое число, а затем преобразовать в строку:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n/fraction = 1.5  # Дробь \nprint(\"Целая часть = \" + str(int(fraction)))\n# Вернётся строка, представляющая собой целочисленную часть дроби.\n# Выполните этот код в окне тренажёра и посмотрите, что получится. \n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nПолучится так:\n\nЦелая часть = 1 \n\nДля операций с целыми и дробными числами приводить их к одному типу не нужно, тут Python разберётся сам:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\n/a = 16 * 2.2 + 7 - 0.2\nprint(a)\n# Будет напечатано: 42.0 \n\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nЧто значит «плавающая запятая» и куда она плывет?\nДробные числа называют «числами с плавающей запятой», потому что запятая «плавает» по числу, когда его представляют в виде произведения значащей части и степени. \nНапример, число 3,14159 можно записать следующим образом:\n314,159 ⋅ 10^−2\n0,0314159 ⋅ 10^2\n314159,0 ⋅ 10^−5\nВ англоязычной литературе запятая называется точкой, floating point, потому что десятичные дроби пишутся через точку.\n\n\nЗадание\nДлина Питона из известного советского мультфильма равна 38 попугаев и одно попугайское крылышко. Будем считать, что крылышко равно 0.2 попугая.\nВ железнодорожный вагон можно уложить по длине шесть с половиной Питонов. \nПопробуйте посчитать, какое количество попугаев можно уложить вдоль вагона.\nПопугаи бывают только целые, это важно. Поэтому переменная result должна быть типа int.\n\n//////////////////////////////////////////////////////////////////////\n/snake = '38.2'  # Длина Питона в попугаях\nlength = 6.5  # Количество Питонов, которых можно уложить вдоль вагона.\n# Напишите формулу для вычисления количества попугаев\nresult = ...\nprint('В вагоне можно положить в ряд', result, 'попугаев')\n///////////////////////////////////////////////////////////////////////",
      "isLock": true
    },
    {
      "id": 10,
      "language": "Python",
      "title": "Урок 10. Списки.",
      "text": "Списки — это последовательности чисел, строк или каких-то ещё значений.\nВы уже присваивали переменным числовые и строковые значения, точно так же переменная может содержать и список.\nСодержимое списка пишется в квадратных скобках, элементы списка разделяются запятой:\n\nnew_list = [<элемент>, <элемент>, <элемент>, <элемент>, <элемент>]\n\nВ переменной russian_alphabet сохраним список, состоящий из букв алфавита. Буква — это строка, поэтому каждый элемент — в кавычках:\n\nrussian_alphabet = ['а','б','в','г','д','е','ё','ж','з','и','й','к','л','м','н','о','п','р','с','т','у','ф','х','ц','ч','ш','щ','ъ','ы','ь','э','ю','я']\n\nЧто содержит переменная russian_alphabet?\n\nprint(russian_alphabet)\n# Будет напечатано:\n# ['а', 'б', 'в', 'г', 'д', 'е', 'ё', 'ж', 'з', 'и', 'й', 'к', 'л', 'м', 'н', 'о', 'п', 'р', 'с', 'т', 'у', 'ф', 'х', 'ц', 'ч', 'ш', 'щ', 'ъ', 'ы', 'ь', 'э', 'ю', 'я']\n\nУ каждого элемента есть свой порядковый номер — индекс. С помощью индекса можно получить значение элемента списка.\nПроверьте в онлайн компиляторе, что выведет этот код:\n\nrussian_alphabet = ['а','б','в','г','д','е','ё','ж','з','и','й','к','л','м','н','о','п','р','с','т','у','ф','х','ц','ч','ш','щ','ъ','ы','ь','э','ю','я']\nprint(russian_alphabet[1])  # Напечатать содержимое элемента с индексом 1\nprint(russian_alphabet[2])  # Напечатать содержимое элемента с индексом 2\n\nНеожиданность: будет напечатано\nб\nв\n\nХм, индекс 1 выдал не первый элемент списка, а второй. Ошибки здесь нет — счёт в списках начинается с нуля.\nУ первого элемента индекс нулевой:\nprint(russian_alphabet[0])  # Напечатать содержимое элемента с индексом 0\n# Будет напечатано: а\n\nСписок из чисел может выглядеть так:\n\ncountdown = [5, 4, 3, 2, 1, 0]\n\nМожно сделать список из выражений, тогда в нём будут храниться вычисленные значения:\n\n# сохраним в списках вторую и третью строки таблицы Пифагора\npythagoras_2 = [\n    2*1, 2*2, 2*3, 2*4, 2*5, 2*6, 2*7, 2*8, 2*9\n]\npythagoras_3 = [\n    3*1, 3*2, 3*3, 3*4, 3*5, 3*6, 3*7, 3*8, 3*9\n]\nprint(pythagoras_2)\nprint(pythagoras_3)\n\nРезультат:\n[2, 4, 6, 8, 10, 12, 14, 16, 18]\n[3, 6, 9, 12, 15, 18, 21, 24, 27]\n\nК списку, который хранится в переменной, можно прибавить другой список. Для примера наберём участников в группу «Бременские музыканты»:\n\ntrubadur = ['Трубадур']\nanimals = ['Кот', 'Пёс', 'Осёл', 'Петух']\n\nbremen_musicians = trubadur + animals\nprint(bremen_musicians)\n\n# Будет напечатано: ['Трубадур', 'Кот', 'Пёс', 'Осёл', 'Петух']\n\nДля подсчёта элементов списка есть стандартная функция len().\n\ncount = len(bremen_musicians)\nprint(count)\n# Будет напечатано: 5\n\nЗадание 1.\nПопробуйте написать программу, которая будет приветствовать людей из списка. Для начала пускай программа поздоровается с Соней.\nДопишите код так, чтобы ваша программа напечатала фразу Привет, Соня!\n\nfriends = ['Сергей', 'Соня', 'Дима', 'Алина', 'Егор']\nindex = ...\nprint('Привет, ' + friends[index] + '!')\n\nДобавим программе немного функциональности. Научим её считать друзей.\n1. Объявите переменную count и сохраните в ней количество друзей. Посчитайте их вызовом функции len().\n2. Выведите на экран строку У тебя {количество} друзей, где {количество} — значение переменной count.\n\nprint(\"Привет!\")\nfriends = ['Сергей', 'Соня', 'Дима', 'Алина', 'Егор']\ncount = ...\nprint(\"У тебя\", count, \"друзей\")",
      "isLock": true
    },
    {
      "id": 11,
      "language": "Python",
      "title": "Урок 11. Циклы.",
      "text": "В обычной жизни зачастую приходится выполнять серии одинаковых операций. Например, задача «перемыть эту груду грязных тарелок» решается так: взять тарелку — помыть — сполоснуть — вытереть — убрать — взять следующую тарелку — помыть — ...и повторять по кругу.\n\nЭтот процесс не бесконечен: работа должна продолжаться лишь при условии, что остались грязные тарелки. Тарелки кончились — работа прекращается.\n\nВ разработке тоже приходится выполнять одинаковые действия со всеми элементами списка, это довольно востребованная операция.\n\nНапример, если есть список музыкантов, можно напечатать их имена:\n\nbremen_musicians = ['Кот', 'Пёс', 'Трубадур', 'Осёл', 'Петух']\nfor musician in bremen_musicians:\n    print(musician)\n\n# Будет напечатано:\n# Кот\n# Пёс\n# Трубадур\n# Осёл\n# Петух\n\nЦикл for ... in ... позволяет перебрать все элементы списка и выполнить для них одни и те же действия.\n\nТеперь напечатайте с помощью цикла названия месяцев из списка months:\n\nmonths = ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь']\nfor month in months:\n    print(month)\n",
      "isLock": true
    },
    {
      "id": 12,
      "language": "Python",
      "title": "Отступы в коде циклов.",
      "text": "Код программы, написанной на любом современном языке программирования, делится на логические блоки. Чтобы и компьютеру, и человеку было понятно, где начинается и где заканчивается определённый блок — блоки надо как-то отделять друг от друга.\n\nНапример, цикл — это отдельный блок кода. Тело цикла должно быть отделено от остального кода, чтобы компьютер знал, какие именно инструкции надо выполнять в цикле. В качестве основного средства формирования блоков кода в Python используются отступы.\n\nВ Python отступ — это пустое место в начале строки кода. Каждый вложенный блок отбивается от начала строки четырьмя отступами; код, следующий за блоком, снова пишут от начала строки. В качестве отступов используются пробелы или табы.\n\nТабы или пробелы?\nВ Python отступы можно задавать пробелами или табами — невидимыми символами, которые печатаются при нажатии клавиши Tab. Но есть важное ограничение: в коде нельзя одновременно использовать и табы, и пробелы; Python этого не поймёт, нужно выбрать что-то одно.\n\nПример ошибки:\n\"\"\"python\n numbers = [1, 2, 3]\n for number in numbers:\n     print('Печатаем элемент списка')\n\tprint(number)\n\"\"\"\n\nОшибка: Inconsistent use of tabs and spaces in indentation.\nИсправленный код:\n\"\"\"python\n numbers = [1, 2, 3]\n for number in numbers:\n     print('Печатаем элемент списка')\n     print(number)\n\"\"\"\n\nОтступы во вложенных циклах\nЦиклы можно вкладывать друг в друга, при этом вложенный цикл будет выполняться для каждой итерации внешнего цикла. Такие циклы называются вложенными.\n\nПример:\n\"\"\"python\n kids = ['Витя', 'Маша', 'Марина']\n sweets = ['Батончик', 'Сникерс', 'Мишка Косолапый', 'Коровка']\n for kid in kids:\n     for sweet in sweets:\n         print(kid, 'получает конфету', sweet)\n\"\"\"\n\nЗадание 1: Исправьте отступы в следующем коде:\n\"\"\"python\n kids = ['Витя', 'Маша', 'Марина']\n sweets = ['Батончик', 'Сникерс', 'Мишка Косолапый', 'Коровка']\n for kid in kids:\n for sweet in sweets:\n print(kid, 'получает конфету', sweet)\n\"\"\"\n\nЗадание 2: Напечатайте таблицу умножения с правильными отступами.\n\"\"\"python\n numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n for number_1 in numbers:\n for number_2 in numbers:\n print(number_1, '*', number_2, '=', number_1 * number_2)\n\"\"\"",
      "isLock": true
    },
    {
      "id": 13,
      "language": "Python",
      "title": "Урок 13. Диапазоны от и до.",
      "text": "Зачастую возникает необходимость создать и обработать последовательность целых чисел в определённом диапазоне. \nНапример, когда нужно узнать сумму всех целых чисел от 3 до 5 или просто перечислить все номера вагонов поезда.\nМожно вручную создать список из чисел, либо выбрать способ проще: в Python есть функция range(), в которую передаются два целых числа:\nначало и конец диапазона. В результате будет создана последовательность, включающая все целые числа в указанном диапазоне.\nОсобенность этой последовательности в том, что в неё не включается последнее число диапазона:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nthree = range(0, 3)\n# Последовательность three будет включать в себя числа 0, 1 и 2.\n# Тройка в эту последовательность не войдёт: \n# последнее число в последовательность не включается.\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nЧисла могут быть и отрицательными. Важно, чтобы первое число было меньше второго.\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\naround_zero = range(-3, 3)\n# Последовательность around_zero будет включать в себя числа -3, -2, -1, 0, 1 и 2.\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nПриятная особенность последовательности range() в том, что её можно обрабатывать в цикле, как обычный список. \nНапример, можно сделать так:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\naround_zero = range(-3, 3)\n# Вместо списка в цикл передаётся переменная around_zero, \n# в ней хранится range() от -3 до 3\nfor i in around_zero:\n    # Перебрать все числа в диапазоне от -3 до 3 и напечатать их:\n    print(i)\n# Будет напечатано\n# -3\n# -2\n# -1\n# 0\n# 1\n# 2\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nВнутреннюю переменную цикла, в которую передаются числа из последовательности, традиционно называют i, но её можно назвать как угодно.\nЗадать диапазон можно прямо в условии цикла, без промежуточной переменной around_zero.\nСписок вагонов через range()\nЗапустите код в онлайн компиляторе и посмотрите, что он напечатает. Замените в range() параметры на любые случайные — и вновь запустите код. \nБудьте внимательны: второе число в range() — это значение, перед которым останавливается счётчик. \nЭто число не включается в последовательность. Например, чтобы обработать числа от 1 до 100 включительно — диапазон должен быть таким: range(1, 101).\n\n//////////////////////////////\nfor i in range(1, 5):\n    print(\"Вагон №\" + str(i))\n//////////////////////////////\n\n\nЗадание 1.\nКак и в ситуации с обычным списком, цикл будет по очереди передавать каждое число из диапазона range в переменную i. А в теле цикла эта переменная будет печататься.\nВ этом уроке четыре задачи. Напечатайте магическую мантру, которая поможет справиться с ними:\nЯ расправлюсь с задачей 1\nЯ расправлюсь с задачей 2\nЯ расправлюсь с задачей 3\nЯ расправлюсь с задачей 4\nЯ гений питона! \nВместо многоточий вставьте необходимый код — имя переменной и диапазон.\nВнутреннюю переменную цикла можно назвать i: так традиционно называют переменную, принимающую числа из последовательного числового ряда.\n\n/////////////////////////////////////////\nfor ... in range(...):\n    print('Я расправлюсь с задачей', ...)\nprint('Я гений питона!')\n/////////////////////////////////////////\n\n\nСписок задом наперёд\nЕсли нужно пройтись по списку или по диапазону чисел в обратном порядке — вызывайте функцию reversed(): \nона переворачивает и список, и диапазон; чтение любой последовательности начнётся с конца.\nДля примера напишем симулятор новогодних курантов.\nФункция range() не включает в последовательность чисел второй аргумент, поэтому для reversed(range(1, 13)) отсчёт начнётся с 12.\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfor i in reversed(range(1, 13)):\n    print(i, 'бомм!')\nprint('C новым годом!')\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nФункция reversed() может развернуть в обратном направлении любую последовательность:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n# Можно обратить вспять обычный список: \nseasons = ['зима', 'весна', 'лето', 'осень']\nfor season in reversed(seasons):  \n    # Переменную цикла, в которую будут передаваться элементы «перевёрнутого» списка seasons,\n    # назовём season\n    print(season)\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\n\nЗадание 2.\nРазверните год наоборот: напечатайте месяцы в обратном порядке.\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\nmonths = ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь']\nfor ... in ...:\n    print(...)\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\nПолезная переменная снаружи цикла\nПочему бы теперь не написать циклом стихотворение про зайчика:\n1, 2, 3, 4, 5, вышел зайчик погулять!  \nЗдесь числа и фрагмент текста объединены в одну строку. Это означает, что задачу не удастся решить, \nпечатая числа прямо из цикла (в этом случае каждое число окажется на отдельной строке).\nСначала все части строки нужно записать в дополнительную переменную, и потом напечатать её одним вызовом print().\nЭту переменную назовём bunny_counter и объявим снаружи цикла. На каждой итерации цикла будем дописывать в неё очередное число из range(). \nВыведем на печать эту переменную и фразу «вышел зайчик погулять!» — и готово.\nЧисла из range() надо преобразовать в строку, иначе не получится объединить их с текстовой строкой.\nЗапустите код, и искусственный почти-разум напишет своё первое стихотворение.\n\n////////////////////////////////////////////////////////////////////////////////////\nbunny_counter = ''  # Создали переменную bunny_counter, её значение - пустая строка.\nfor i in range(1, 6):\n    # На каждой итерации цикла\n    # к переменной bunny_counter будет дописываться\n    # очередная цифра, запятая и пробел (чтобы числа в строке не слиплись).\n    # Получившееся значение будет присвоено той же переменной bunny_counter\n    bunny_counter = bunny_counter + str(i) + ', '\nprint(bunny_counter + 'вышел зайчик погулять!')\n////////////////////////////////////////////////////////////////////////////////////\nПопробуйте изменить код и запустить его вновь. Например, можно досчитать до другого числа и выдумать новую рифму.",
      "isLock": true
    },
    {
      "id": 14,
      "language": "Python",
      "title": "Урок 14. Ветвления.",
      "text": "Кроме арифметических выражений, в Python есть логические, которые возвращают ответ: выражение истинное или ложное. \nНапример, равенство проверяется оператором ==. Новички часто путают его с присваиванием =.\nВ выражении x = 5 применён оператор присваивания: переменной x присвоено значение 5.\nВыражение x == 5, в котором применён логический оператор «равно» — это вопрос: «А правда ли, что x равен пяти?». \nВ зависимости от того, какое значение присвоено переменной x, программа даст ответ (вернёт значение): «Да, правда», True; или «Нет, не правда», False.\nЕщё числа можно сравнивать операторами < (меньше) и > (больше).\n5 < 3: «А правда ли, что 5 меньше трёх?». Ответ: False.\n100 > 1: «Действительно ли сто больше одного?». Ответ: True.\nРезультат проверки определяется особыми логическими значениями True или False.\nЧтобы узнать, истинно или ложно утверждение, сохраним выражение в переменной с именем check и выведем её значение на экран. \nПроверим, считает ли Python истинными выражения «дважды два больше шести» и «дважды два — четыре».\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\ncheck = (2*2 > 6)\nprint(check)\n# Будет напечатано: False\n\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nPython вернул значение False. Следовательно, «дважды два больше шести» — не верное, ложное утверждение.\n\n\\\\\\\\\\\\\\\\\\\\\\\\\ncheck = (2*2 == 4)\nprint(check)\n# Будет напечатано: True \n\\\\\\\\\\\\\\\\\\\\\\\\\n\n\nВетвление кода\nВетвления позволяют писать код, который исполняется, когда логическое выражение истинно.\n\nВетвление объявляют оператором if. После if пишут условие — логическое выражение, результатом которого может быть True или False. \nЕсли выражение в условии истинно, то выполняется код, написанный после двоеточия. Если ложно, код после условия не сработает.\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nif <условие>:\n    <код, который выполнится, если условие вернуло True> \n    # Внимание: код после if должен быть отбит от начала строки 4-мя пробелами\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nПроанализируем скорость ветра по двенадцатибалльной шкале Бофорта, используя ветвления в Python.\nПротестируйте программу: сперва запустите код как есть, а потом измените значение переменной beaufort с нуля на любое другое значение.\n\n//////////////////////////////////////////////////////////////////////////////////////\n# Проверим значение переменной beaufort.\n# Если ветер в 0 баллов, то сообщим о штиле (ветра нет).\nbeaufort = 0\nif beaufort == 0:\n    print('Штиль')\n# А если условие ложно (сила ветра не равна нулю) - этот фрагмент кода будет пропущен \n# и не произойдёт вообще ничего\n//////////////////////////////////////////////////////////////////////////////////////\n\nОператор if может включать блок кода, который выполнится в том случае, если условие ложно. Для этого существует конструкция if / else. \nЕсли условное выражение истинно, выполняется код из блока if, а если условие ложно — сработает код из блока else.\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nif <условие>:\n    <код, который выполнится, если условие истинно> \n    # Внимание: блок кода под if должен быть отбит 4 пробелами от начала строки с инструкцией if\nelse:\n    <код, который выполнится, если условие ложно>\n    # Этот блок тоже отбит от начала строки c if 4 пробелами \n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nИнструкция else всегда работает c if. Если условие в if ложно, то выполнится код, который написан в else. \nПри этом if может использоваться без else, но else без if — никогда. Такой код не имеет смысла и не заработает.\n\nПотестируйте этот код, изменяя значение переменной beaufort.\n\n////////////////////////////////////////////////////////////////////\n# Проверим значение переменной beaufort.\n# Если ветер в 0 баллов, то сообщим о штиле,\n# в любом другом случае сообщим, что ветер есть.\nbeaufort = 0\nif beaufort == 0:\n    print('Штиль')\nelse:\n    # Если не сработало условие в if - выполняется код в блоке else\n    print('Есть ветер')\n///////////////////////////////////////////////////////////////////\n\n\nЗадание 1.\nДополните код: в случае, если переменная messages_count равна нулю — программа должна печатать фразу 'У вас нет сообщений'.\n\n////////////////////////////////////////////////////////\nfor messages_count in range(6):\n    if messages_count > 0:\n        print('Новых сообщений: ' + str(messages_count))\n////////////////////////////////////////////////////////\n\n\nЗадание 2.\nФункция range(24) перебирает все числа от 0 до 23 и по очереди передаёт их в тело цикла в переменную current_hour («текущее время»).\nНаучите программу желать вам доброго утра, если в переменной current_hour записано значение меньше 12.\nОбратите внимание на отступы, в коде они расставлены правильно:\n•\t4 отступа перед if (ведь он вложен в блок for);\n•\t8 отступов перед print() (ведь он вложен в if, который вложен в for).\n\n////////////////////////////////\nfor current_hour in range(24):\n    if  # напишите условие здесь\n        print('Доброе утро!')\n////////////////////////////////",
      "isLock": true
    },
    {
      "id": 15,
      "language": "Python",
      "title": "Урок 15. Множественные ветвления.",
      "text": "Пока что программа оценки силы ветра различает лишь два состояния: есть ветер / нет ветра. \n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nif beaufort == 0:\n    print('Штиль')\nelse:\n    print('Есть ветер')\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nНо для нормальной оценки силы ветра по шкале Бофорта нужно учитывать градации. Можно сделать такую программу с конструкцией else:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nif beaufort == 0:\n    print('Штиль')\nelse:\n    if beaufort == 1:\n        print('Тихий ветер')\n    else:\n        if beaufort == 2:\n            print('Лёгкий ветер')\n        else:\n            if beaufort == 3:\n                print('Слабый ветер')\n            else:\n                if beaufort == 4:\n                    print('Умеренный ветер')\n                else:\n                    if beaufort == 5:\n                        print('Свежий ветер')\n                    else:\n                        if beaufort == 6:\n                            print('Сильный ветер')\n                        else:\n                            print('Шторм') \n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nТакой код состоит из множества вложенных друг в друга условных операторов, и каждый вложенный блок отделяется четырьмя пробелами слева, \nчто усложняет и без того непростое восприятие.\nКод конструкции можно упростить при помощи elif. Инструкция elif — это вложенная конструкция для if: \n«Если условие для if не выполнено, но выполняется условие для elif — выполнить код в блоке elif».\nКак и для оператора if, в elif должно быть установлено условие, логическое выражение, которое вернёт True или False.\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nif beaufort == 0:\n    print('Штиль')\nelif beaufort == 1:\n    print('Тихий ветер')\nelif beaufort == 2:\n    print('Лёгкий ветер')\n...\nelse:\n    # Если не сработало ни одно условие в предыдущем коде - выполняется код в блоке else\n    print('Шторм')\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nКак только выполняется одно из условий, все следующие elif и else игнорируются.\nПотестируйте этот код: самостоятельно объявите переменную beaufort, присвойте ей значение и выполните код. \nИзмените силу ветра, посмотрите, что получится. Устройте шторм, это освежит вас после теории.\n\n////////////////////////////////////////////////////////////\n# Укажите значение для переменной beaufort и запустите код.\nbeaufort = \n\nif beaufort == 0:\n    print('Штиль')\nelif beaufort == 1:\n    print('Тихий ветер')\nelif beaufort == 2:\n    print('Лёгкий ветер')\nelif beaufort == 3:\n    print('Слабый ветер')\nelif beaufort == 4:\n    print('Умеренный ветер')\nelif beaufort == 5:\n    print('Свежий ветер')\nelif beaufort == 6:\n    print('Сильный ветер')\nelse:    \n    print('Шторм')\n////////////////////////////////////////////////////////////\n\n\nЗадание 1.\nПросклоняйте слово «сообщения» в зависимости от их количества:\n•\tдля 0 — 'У вас нет новых сообщений'\n•\tдля 1 — 'У вас 1 новое сообщение'\n•\tот 2 до 4 включительно — 'У вас <количество> новых сообщения'\n•\tлюбое другое количество — 'У вас <количество> новых сообщений'\n\n//////////////////////////////////////////////////////////\nfor messages_count in range(0, 21):\n    if messages_count == 0:\n        print('У вас нет новых сообщений')\n    elif messages_count == ...:\n        print('У вас 1 новое сообщение')\n    elif messages_count < ...:\n        print('У вас', messages_count, 'новых сообщения')\n    else:\n        print(...)\n//////////////////////////////////////////////////////////\n\n\nЗадание 2.\nПрограмма умеет здороваться утром и днём, но ведь ещё есть вечер и ночь! Прокачайте навыки программы: дополнительно научите её желать доброго вечера и доброй ночи.\nРасширьте ветвление if новыми условиями так, чтобы приветствия программы соответствовали времени суток:\n\n       Время\t\t\t\t|Текст приветствия|\nстрого меньше 6\t\t\t\t|  Доброй ночи!   |\nот 6 включительно, но строго меньше 12\t|  Доброе утро!   |\nот 12 включительно, но строго меньше 18\t|  Добрый день!   |\nот 18 включительно, но строго меньше 23\t|  Добрый вечер!  |\nв остальных случаях \t\t\t|  Доброй ночи!   |\n\nНапример, в 6 утра программа должна сказать «Доброе утро!», а в 18 часов — «Добрый вечер!».\nПрограмма должна напечатать сообщения для каждого часа в сутках, итого — 24 сообщения.\n\n///////////////////////////////////////////////////\nfor current_hour in range(0, 24):\n    print(\"На часах \" + str(current_hour) + \":00.\")\n    # Вместо многоточий напишите код\n    if current_hour ...\n        print(...) \n    # Допишите программу\n///////////////////////////////////////////////////",
      "isLock": true
    },
    {
      "id": 16,
      "language": "Python",
      "title": "Урок 16. Логические выражения.",
      "text": "Кроме простых операторов сравнения \n•\t«равно» ==,\n•\t«меньше» <,\n•\t«больше» >,\nесть и более сложные операторы, учитывающие сразу два условия: \n•\tбольше или равно >=,\n•\tменьше или равно <=,\n•\tне равно !=.\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n# Если ветер шесть баллов или больше\nif beaufort >= 6:\n    print('Будьте осторожны, сильный ветер!')\n\n# Если ветер в четыре балла или менее\nif beaufort <= 4:\n    print('Лёгкий ветер')\n\n# Если есть хоть какой-то ветер \nif beaufort != 0:\n    print('Ветрено') \n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nКогда нужно выбирать между двумя условиями, в ход идут логические операции.\nОператор or, «логическое ИЛИ», возвращает True, если хотя бы одно из условий истинно.\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n# Если ветер в 7 или 8 баллов, то он называется крепким\nif beaufort == 0:\n    print('Штиль')\nelif beaufort == 1:\n    print('Тихий ветер')\nelif beaufort == 2:\n    print('Лёгкий ветер')\nelif beaufort == 3:\n    print('Слабый ветер')\nelif beaufort == 4:\n    print('Умеренный ветер')\nelif beaufort == 5:\n    print('Свежий ветер')\nelif beaufort == 6:\n    print('Сильный ветер')\nelif beaufort == 7 or beaufort == 8:\n    print('Крепкий ветер') \n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nЕсли первый аргумент оператора or возвращает True, то второй аргумент не оценивается, так как ответ уже ясен. \nОператор and, «логическое И», возвращает True, только если оба условия истинны.\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n# если ветер от 9 до 11 баллов, то это шторм (различной силы)\nif beaufort == 0:\n    print('Штиль')\nelif beaufort == 1:\n    print('Тихий ветер')\nelif beaufort == 2:\n    print('Лёгкий ветер')\nelif beaufort == 3:\n    print('Слабый ветер')\nelif beaufort == 4:\n    print('Умеренный ветер')\nelif beaufort == 5:\n    print('Свежий ветер')\nelif beaufort == 6:\n    print('Сильный')\nelif beaufort == 7 or beaufort == 8:\n    print('Крепкий ветер')\nelif beaufort >= 9 and beaufort <= 11:\n    print('Шторм')\nelif beaufort == 12:\n    print('Ураган')\nelse:  # else тоже может быть в конце, после цепочки elif\n    print('Неизвестное значение') \n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nЕсли один из аргументов оператора and возвращает False, то другой аргумент уже не оценивается: оператор в любом случае вернёт False.\n\n\nЗадание 1.\nЗамените многоточия в условиях логическим оператором and или or.\n\n///////////////////////////////////////////////////\nfor current_hour in range(0, 24):\n    print(\"На часах \" + str(current_hour) + \":00.\")\n    if current_hour >= 6 ... current_hour <= 11 :  \n        print('Доброе утро!')\n    elif current_hour >= 12 ... current_hour <= 17:  \n        print('Добрый день!')\n    elif current_hour >= 18 ... current_hour <= 22:                       \n        print('Добрый вечер!')\n    elif current_hour <= 5 ... current_hour >= 23:\n        print('Доброй ночи!')\n///////////////////////////////////////////////////",
      "isLock": true
    },
    {
      "id": 17,
      "language": "Python",
      "title": "Урок 17. Составные логические выражения.",
      "text": "Логические операторы можно объединять в составные выражения. В таких выражениях операторы выполняются не в порядке записи, а в порядке приоритета: высший приоритет у not, затем выполняется and, а последним — or.\nС оператором not вы ещё не встречались.\nОператор not: not True == False\nОператор not — это логическое отрицание, он возвращает True, если выражение равно False и наоборот.\nДля примера можно вывести на печать результаты применения оператора not:\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nprint(True)\n# Без неожиданностей, будет напечатано: True\nprint(not True)\n# Будет напечатано: False\nprint(not False)\n# Будет напечатано: True\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nЛюбая операция сравнения возвращает True или False. А оператор not просто превращает эти значения в их противоположности:\n\\\\\\\\\\\\\\\\\\\\\\\\\nprint(5 > 3)\n# Будет напечатано: True\nprint(not 5 > 3)\n# Будет напечатано: False\n\\\\\\\\\\\\\\\\\\\\\\\\\nnot на практике\nНапечатаем на экране стихотворение о погоде. Текст зависит от того, какое значение присвоено переменной wind.\nПотестируйте программу: сначала запустите её как есть, а затем присвойте переменной wind значение False и запустите код снова.\nА если убрать из кода оператор not (попробуйте и это) — программа начнёт печатать неподходящие к погоде строки.\n///////////////////////////////////////\nwind = True\n# Есть ли ветер?\nif not wind: # Если wind НЕ равен True\n    print('Ночь тиха')\nelse:\n    print('Поднялся ветер')\n    print('Серые тучи развеял')\n    print('Новые тянутся с юга')\n///////////////////////////////////////\nХайку — признак ветреной погоды, а если ветра нет — и говорить не о чем, можно обойтись одной строкой. А без not всё наоборот!\nПриоритетность логических операторов\nИтак, в любом составном выражении сначала выполняется оператор not, затем — and, а последним — or.\nИ о погоде\nТеперь напишем программу, которая по совокупности данных определяет погоду и выводит на экран сообщение Идём гулять, на улице хорошо, если:\n• не идёт дождь или не сильно ветрено (ветер одновременно с дождём — это неприятно);\n• при этом температура воздуха больше 22 градусов.\nПрограмма состоит из нескольких логических выражений:\n////////////////////////////////////////////////////////\n# Передадим в программу данные\nbeaufort = 6        # Сильный ветер\nis_raining = False  # Дождя нет\ntemperature = 16    # Не жарко\nif not is_raining or beaufort <= 4 and temperature > 22:\n    print('Идём гулять, на улице хорошо')\nelse:\n    print('Сидим дома, читаем Практикум')\n////////////////////////////////////////////////////////\nСтранный результат, что-то пошло не так.\nКак так «на улице хорошо», если за окном лишь 16 градусов, а прогулка предусмотрена от +22°?\nРазберёмся.\nВначале вычисляется значение каждого выражения, в том числе и с not:\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nnot is_raining — результат True\nbeaufort <= 4 — результат False\ntemperature > 22 — результат False\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nЗатем применяются оставшиеся логические операторы, сначала and, у него приоритет выше\nbeaufort <= 4 and temperature > 22 → False and False → False\nДалее идет проверка: если истинно хотя бы одно из условий, not is_raining или beaufort <= 4 and temperature > 22 — сообщается о хорошей погоде.\nДа, выражение not is_raining истинно, значит, выводится сообщение Идём гулять, на улице хорошо, хотя на самом деле всё наоборот.\nЧтобы исправить код — переопределим порядок вычислений скобками:\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n# передадим в программу данные\nbeaufort = 6  # сильный ветер\nis_raining = False  # дождя нет\ntemperature = 16\nif (not is_raining or beaufort <= 4) and temperature > 22:\n    print('Идём гулять, на улице хорошо')\nelse:\n    print('Сидим дома, читаем книгу')\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nДа, ответ верный, для прогулки в шортах прохладно и ветрено, самое время покодить.\nТеперь вычисления прошли в нужном порядке, в первую очередь были выполнены операции в скобках:\n1. not is_raining or beaufort <= 4 → True or False → True\n2. (not is_raining or beaufort <= 4) and temperature > 22 → True and False → False\nЗадание 1.\nГотовим завтрак. В зависимости от наличия продуктов есть разные варианты меню:\n• Если есть молоко (milk) и хлопья (cereals) — можно позавтракать хлопьями с молоком.\n• Если есть яйца (eggs) — на завтрак будет яичница.\n• Если есть молоко и яйца — можно сотворить омлет.\n• Есть и более бюджетные варианты: попить молока, погрызть сухих хлопьев или вовсе не завтракать.\nПрочтите код, отследите логику ветвления.\nПодставьте вместо многоточия такой логический оператор, с которым программа будет работать корректно.\n////////////////////////////////////////////////////////\n# Продуктов маловато:\nmilk = not True       # Молоко \"НЕ есть\".\ncereals = True        # Хлопья есть.\neggs = False          # Яиц нет.\n\n# Вставьте логический оператор вместо многоточия.\n# Решите, нужно ли расставить скобки.\n\nif milk ... cereals or eggs:\n    if eggs:\n        if milk:\n            breakfast = \"- омлет\"\n        else:\n            breakfast = \"- яичница\"\n    else:\n        breakfast = \"- хлопья с молоком\"\nelse:\n    if milk:\n        breakfast = \"- стакан молока\"\n    elif cereals:\n        breakfast = \"можно погрызть сухих хлопьев\"\n    else:\n        breakfast = \"ничего не будет: разгрузочный день\"\n\nprint(\"Сегодня на завтрак\", breakfast)\n////////////////////////////////////////////////////////",
      "isLock": true
    },
    {
      "id": 18,
      "language": "Python",
      "title": "Урок 18. Функции.",
      "text": "Иногда в разных частях программы нужно выполнять одинаковые действия.\nСамый простой подход в такой ситуации — взять готовый кусок кода и скопировать его туда, где требуется повторить выполнение.\nНапример, раз в минуту программа должна проверять входящую почту: если появились новые письма — переменная new_mail станет больше ноля, и программа сообщит об этом.\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nnew_mail = 0\nif new_mail > 0:\n    print('Пришло письмо, не пропусти!')\nelse:\n    print('Никто не пишет.')\n# Тут код, отсчитывающий минуту\n# И снова проверим почту\nif new_mail > 0:\n    print('Пришло письмо, не пропусти!')\nelse:\n    print('Никто не пишет.')\n# Тут код, отсчитывающий минуту\n# И снова\nif new_mail > 0:\n    print('Пришло письмо, не пропусти!')\nelse:\n    print('Никто не пишет.')\n# Тут код, отсчитывающий минуту\n# За это время пришло письмо:\nnew_mail = 1\n# И снова проверка\nif new_mail > 0:\n    print('Пришло письмо, не пропусти!')\nelse:\n    print('Никто не пишет.')\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nРаботает? Работает.\nНо сколько же нужно кода, чтобы проверка работала круглые сутки?\nЕсли программа сложная — она очень быстро превратится в винегрет из повторяющихся фрагментов кода, разобраться в котором будет невозможно.\nОт хаоса и беспросветности разработчиков спасают функции.\nФункция — это именованный блок кода, выполняющий определённую задачу. Код функции можно использовать многократно, надо лишь вызвать её — обратиться к ней по имени.\nВ Python есть множество заготовленных (встроенных) функций, некоторые вы уже вызывали: print(), str(), int(), float(), len().\nНо можно создавать и собственные функции.\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nnew_mail = 0\n# Создадим собственную функцию и дадим ей имя check_mail (\"проверка писем\")\n# В эту функцию поместим код проверки количества писем.\ndef check_mail():\n    if new_mail > 0:\n        print('Пришло письмо, не пропусти!')\n    else:\n        print('Никто не пишет.')\n# Тут код, отсчитывающий минуту\n# Проверим почту - вызовем функцию check_mail():\n# запустим код, который хранится в функции.\ncheck_mail()\n# Тут код, отсчитывающий минуту\n# И снова вызовем функцию:\ncheck_mail()\n# Тут код, отсчитывающий минуту\n# За это время пришло письмо:\nnew_mail = 1\n# И снова вызовем функцию:\ncheck_mail()\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nКод стал гораздо короче, а работает точно так же. Удобно, красиво, лаконично.\n\nОбъявление функции\nВсё начинается с объявления функции, со строки, которая означает «здесь мы создаём новую функцию».\nФункцию объявляют ключевым словом def, затем указывают имя функции (его придумывает разработчик), после имени — круглые скобки и двоеточие.\n...\n\n///////////////////////////////////////////////////////////////\n# Теперь у функции hello() два параметра: name и bonus\ndef hello(name, bonus):\n    # Оба параметра применим в теле функции:\n    print(name + ', приветствую тебя! Бери ' + bonus)\nhello('Дарт Вейдер', 'печеньки')\nhello('Винни Пух', 'мёд')\n///////////////////////////////////////////////////////////////\n\nФункция — такой же составной блок программы, как циклы и операторы ветвления. Их можно комбинировать между собой.\n...\n\nПервая функция\nЗапустите программу в онлайн компиляторе и посмотрите на результат:\n\n//////////////////////////////////////////////////////////////////\n# Код функции say_hello()\ndef say_hello(current_hour):\n    if current_hour <= 5 or current_hour >= 23:\n        print('Доброй ночи!')\n    elif current_hour >= 6 and current_hour <= 11:\n        print('Доброе утро!')\n    elif current_hour >= 12 and current_hour <= 17:\n        print('Добрый день!')\n    elif current_hour >= 18 and current_hour <= 22:\n        print('Добрый вечер!')\n# Несколько раз вызовем функцию say_hello() с разными аргументами:\nsay_hello(4)\nsay_hello(10)\nsay_hello(15)\nsay_hello(20)\n//////////////////////////////////////////////////////////////////\n\nЗадание 1\nСоздайте функцию say_about() для вывода приветственного сообщения программы.\n\n//////////////////////////////////////////////////////////////\n# Здесь объявите функцию say_about()\ndef say_about():\n    print('Привет, я Анфиса!')\n    print('Я персональный помощник.')\n    print('Я ещё маленькая,')\n    print('но постоянно расту и умнею:')\n    print('ведь мой код каждый день дописывают!')\n# Вызовите функцию\nsay_about()\n//////////////////////////////////////////////////////////////\n\nЗадание 2\nНапишите функцию print_friends_count() для вывода количества друзей.\n\n///////////////////////////////////////////////////////////////////\ndef print_friends_count(friends_count):\n    if friends_count == 0:\n        print('У тебя нет друзей')\n    elif friends_count == 1:\n        print('У тебя', friends_count, 'друг')\n    elif friends_count >= 2 and friends_count <= 4:\n        print('У тебя', friends_count, 'друга')\n    elif friends_count >= 5 and friends_count < 20:\n        print('У тебя', friends_count, 'друзей')\n    else:\n        print('Ого, сколько у тебя друзей! Целых', friends_count)\n# Вызовы функции\nprint_friends_count(0)\nprint_friends_count(1)\nprint_friends_count(3)\nprint_friends_count(10)\nprint_friends_count(20)\n///////////////////////////////////////////////////////////////////",
      "isLock": true
    },
    {
      "id": 19,
      "language": "Python",
      "title": "Урок 19. Отступы в коде функций.",
      "text": "Функция — это отдельный блок кода. Вы уже знаете, что блоки надо отделять друг от друга, и для этого в Python используются отступы.\nВ этом уроке вы разберётесь, как корректно использовать отступы в функциях.\nПочему отступы в функциях важны\nОбычно неправильная расстановка отступов в функциях или других блоках кода приводит к тому, что программа просто не запускается, а компьютер сообщает об ошибке. Однако бывает и по-другому.\nПеред вами функция, которая проверяет, сдал студент тест или нет. Результат работы функции должен быть однозначным:\n• Если студент набирает меньше 50 баллов, программа просит пройти тест ещё раз в следующую среду.\n• Если студент набирает больше 50 баллов, программа хвалит студента и сообщает, что тест сдан.\nЗапустите программу в онлайн компиляторе и посмотрите на результат её работы:\n///////////////////////////////////////////////////////////////////////////////\n# Количество баллов, которое студент получил за тест.\nscore = 60\ndef test_score():\n    if score > 50:\n        print('Отличная работа!')\n        print('Тест сдан.')\n    else:\n        print('Хорошая попытка!')\n        print('Вы отлично постарались, но нужно подготовиться чуть получше.')\n        print('Ещё раз пройти тестирование можно в следующую среду.')\ntest_score()\n///////////////////////////////////////////////////////////////////////////////\nСтудент набрал 60 баллов, это больше 50, и получил сообщение, что тест сдан. Всё логично, программа работает правильно.\nА теперь запустите ту же программу, но с неверно расставленными отступами, и посмотрите, что выведется:\n/////////////////////////////////////////////////////////////////////\n# Количество баллов, которое студент получил за тест.\nscore = 60\ndef test_score():\n    if score > 50:\n        print('Отличная работа!')\n        print('Тест сдан.')\n    else:\n        print('Хорошая попытка!')\nprint('Вы отлично постарались, но нужно подготовиться чуть получше.')\nprint('Ещё раз пройти тестирование можно в следующую среду.')\ntest_score()\n/////////////////////////////////////////////////////////////////////\nТак-так-таааак… Программа заблудилась в трёх соснах: тест одновременно и сдан, и не сдан.\nФормально код написан корректно, поэтому компьютер не сообщил об ошибке, но по факту видно, что что-то пошло не так.\nКак расставить отступы в функции\nВсё, что находится внутри функции, выделяется отступами.\nЧисло отступов увеличивается на четыре при использовании каждого нового вложенного блока кода: цикла, условия или функции.\nУсловие находится внутри функции? Будьте добры напечатать восемь пробелов перед телом условия относительно начала строки.\nЧем сложнее ваша программа, тем больше вероятность запутаться в отступах. Поэтому старайтесь внимательно следить за их расстановкой. Иначе поиск ошибки, из-за которой программа работает некорректно, может сильно затянуться, ведь придётся вручную разбирать каждую строчку кода.\nЗадача 1\nПрограммистка Маша написала функцию, которая печатает имена всех её коллег. Но Маша мучается с расстановкой отступов.\nПомогите ей и поправьте код так, чтобы программа заработала как надо, то есть вывела список всех коллег.\n/////////////////////////////////////////////////\nusers = ['Ваня', 'Анатолий', 'Дмитрий', 'Андрей']\ndef print_users(users):\n    for user in users:\n        print(user)\nprint_users(users)\n/////////////////////////////////////////////////\nЗадача 2\nТоня и Стёпа хотят поехать на отдых, но не могут определиться, куда именно: Стёпа настаивает на Карелии, а Тоня — на Сочи. Тоня решила схитрить и написала функцию, которая из всех предложенных вариантов всегда возвращает Сочи. Но форматирование программы сломалось и нужно всё починить.\nПомогите поправить эту функцию, чтобы Тоня и Стёпа смогли поскорее отправиться на заслуженный отдых.\n///////////////////////////////////////////////////////////////////////////////\nresorts = ['Сочи', 'курорты Краснодарского Края', 'Санкт-Петербург', 'Карелию']\ndef choose_vacation_place(resorts):\n    for resort in resorts:\n        if resort == 'Сочи':\n            return resort\nresort = choose_vacation_place(resorts)\nprint('Поехали в ' + resort)\n///////////////////////////////////////////////////////////////////////////////",
      "isLock": true
    },
    {
      "id": 20,
      "language": "Python",
      "title": "Урок 20. Аргументы функции.",
      "text": "Давным-давно, в далёкой-далёкой галактике разработчики написали функцию, которая принимает два аргумента и печатает сообщение.\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ndef print_home(name, planet):\n    print(name + ' живет на планете ' + planet)\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nИногда говорят, что «функция ожидает аргумент»; это значит, что при вызове функции в неё должны быть переданы какие-то значения.\nА что, если функция ждала-ждала аргумент, но не дождалась? Если функцию вызвали, а аргумент, по какой-то причине, не передали?\nПрочтите код, посмотрите на вызов функции: при вызове передан только один аргумент, хотя функция ожидает два.\nЗапустите код в онлайн компиляторе и выясните, что получится.\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ndef print_home(name, planet):\n    print(name + ' живёт на планете ' + planet)\n# Передаём только один аргумент вместо двух\nprint_home('Йода')\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nНичего хорошего не вышло, всё сломалось:\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nTypeError: print_home() missing 1 required positional argument: 'planet'\n# Потерялся обязательный позиционный аргумент 'planet'\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nЧтобы защититься от таких ошибок, при объявлении функции любому параметру можно присвоить «значение по умолчанию»:\nэто значение будет передано параметру, если при вызове функции ожидаемый аргумент не был получен.\nЗначение по умолчанию присваивается параметру при объявлении функции.\nПри вызове не передан второй аргумент, однако функция отработает без ошибок.\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n# Если при вызове забудут передать имя - значением name будет слово 'Инкогнито';\n# а если вызвать функцию, не передав название планеты -\n# функция присвоит переменной planet значение \"Икс\"\ndef print_home(name='Инкогнито', planet='Икс'):\n    print(name + ' живёт на планете ' + planet)\n# Передаём только один аргумент вместо двух\nprint_home('Дроид-пылесос')\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nФраза получилась немного туманной, но ошибок не возникло.\nЗначение по умолчанию будет использовано в том случае, если при вызове функции не был передан ожидаемый аргумент.\nИменованные и позиционные аргументы\nПри вызове функции print_home() значения передаются в параметры соответственно с их позицией, в порядке их перечисления:\nпервый аргумент передаётся в первый параметр, второй аргумент — во второй параметр. Это называется позиционные аргументы.\nЭто просто и удобно, но может вызвать путаницу. Что, если при вызове функции забыли передать первый параметр?\nПри вызове функции забыли передать имя персонажа, и теперь название планеты — единственный, а значит — первый аргумент, и он будет передан в параметр name!\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ndef print_home(name='Инкогнито', planet='Икс'):\n    print(name + ' живёт на планете ' + planet)\nprint_home('Земля')\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nPython увидел, что в функцию передан лишь один аргумент и решил, что это первый позиционный аргумент;\nэтот аргумент был передан в параметр name — и в результате получилась полная чепуха.\nПричина проста: Python не понял, какой именно аргумент был передан при вызове функции.\nЧтобы избежать такой неразберихи, при вызове функции можно передавать именованные аргументы — явно указывать, какому параметру какой аргумент соответствует.\nПрочтите код, обратите внимание на то, как при вызове функции передаются именованные аргументы. Запустите код, посмотрите на результат.\nПоэкспериментируйте с именованными аргументами: вызовите функцию с одним именованным аргументом, потом с другим;\nизмените вызов функции — пусть она напечатает фразу Марк Уотни живёт на планете Марс.\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n# Добавим значение по умолчанию для аргумента name\ndef print_home(name='Инкогнито', planet='Икс'):\n    print(name + ' живёт на планете ' + planet)\n# Передаём именованный параметр:\n# явно указываем, что значение 'Земля' предназначено для параметра planet\nprint_home(planet='Земля')\n# Ещё раз вызовем функцию: передадим два именованных параметра,\n# но не в том порядке, как они указаны в объявлении функции:\nprint_home(planet='Земля', name='Винни Пух')\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nЕсли аргументы поименованы — их можно передавать в любом порядке: функция увидит имена и разберётся.\nЗадание 1\nФункция lets_go() ожидает на вход два аргумента. Если вызвать её без аргументов — она сломается.\nИзмените объявление функции так, чтобы при вызове без аргументов она напечатала фразу Друг, пойдём учить Python.\n/////////////////////////////////////////////////////////////////////////\n# Настройте функцию так, чтобы она не сломалась при вызове без аргументов\ndef lets_go(name, target):\n    print(name + ', пойдём ' + target)\n# Вызовите функцию lets_go без аргументов\n/////////////////////////////////////////////////////////////////////////\nЗадание 2\nЕсли при вызове функции lets_go() передавать неименованные аргументы, то передать только второй аргумент не получится:\nфункция передаст единственный аргумент в параметр name, а не в target, как нам хотелось бы.\nИсправьте вызов функции так, чтобы аргумент, указанный при вызове, был передан в параметр target.\nВызов с именованными аргументами поможет решить эту задачу.\n/////////////////////////////////////////////////\ndef lets_go(name='Друг', target='учить Python'):\n    print(name + ', пойдём ' + target)\n# Исправьте вызов так, чтобы аргумент был передан\n# в параметр с именем target\nlets_go('читать следующий урок!')\n/////////////////////////////////////////////////",
      "isLock": true
    },
    {
      "id": 21,
      "language": "Python",
      "title": "Урок 21. Счётчики.",
      "text": "Одна из популярных задач в программировании — что-нибудь подсчитать: программа в фитнес-трекере может подсчитывать шаги пользователя,\nпрограммное обеспечение лифта может определять его пробег, считая этажи и остановки, программа проектировщика может посчитать,\nсколько на плане помещений определённого размера.\nПосчитаем.\nВ списке flat перечислены площади всех помещений в квартире. Для начала узнаем, сколько всего помещений, это несложно: для определения длины списка есть функция len(), она вернёт количество элементов в списке.\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nflat = [\n    5.55, 22.19, 7.78, 26.86, 5.55,\n    29.84, 22.19, 5.55, 16.85, 4.52\n]\n# len(flat) подсчитает количество элементов в списке flat\n# Сохраним это значение в переменную rooms_num\nrooms_num = len(flat)\n# И напечатаем полученное значение\nprint(rooms_num)\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nА как выяснить, сколько в этом списке помещений, площадь которых равна определённому значению? Найдём количество помещений, площадь которых равна 22.19 м².\nПорядок решения этой задачи может быть таким:\n1. Создаём переменную-счётчик, в ней будем хранить количество обнаруженных помещений нужной площади. Пока что значение этой переменной — ноль.\n2. По очереди берём каждое значение из списка и сравниваем его с 22.19. Чтобы перебрать все значения из списка — применим цикл for ... in ...\n3. Если очередное значение из списка равно 22.19 — увеличиваем значение переменной-счётчика на 1.\n4. Когда все значения списка будут проверены — напечатаем сообщение:\nКомнат площадью {искомая_площадь} кв.м: {значение_счётчика}\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nflat = [\n    5.55, 22.19, 7.78, 26.86, 5.55,\n    29.84, 22.19, 5.55, 16.85, 4.52\n]\n# Сохраним искомое значение в переменной, так будет проще работать.\nroom_size = 22.19\n# В переменной count будем подсчитывать\n# количество обнаруженных помещений нужной площади.\n# Пока что она равна нулю.\ncount = 0\n# Объявляем цикл: из списка flat все значения по очереди будут передаваться\n# в переменную room\nfor room in flat:\n    # Проверяем, равно ли значение переменной room искомому значению\n    if room == room_size:\n        # Если значения room и room_size равны -\n        # переменной count присваиваем её предыдущее значение,\n        # увеличенное на единицу\n        count = count + 1\n# Этот код выполнится только после того,\n# как цикл переберёт все элементы списка flat.\n# В переменной count будет сохранено количество помещений с площадью 22.19\nprint('Комнат площадью', room_size, 'кв.м:', count)\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nПеременную, при помощи которой ведут подсчёт чего-либо, принято называть count,\nдля таких переменных есть общепринятое название — счётчик (англ. count, «сосчитать»).\nОператор += и прочая арифметика\nДобавление одного и того же значения к переменной (в цикле или в других случаях) — достаточно частая операция,\nи для неё придумали специальный оператор: +=.\nС помощью += можно сделать код короче и проще.\n/////////////////////////////////////////////////////////////////////////\n# Например, вместо строки\ncounter = counter + 10  # На каждом шаге counter увеличивается на десять\n# можно написать\ncounter += 10  # На каждом шаге counter увеличивается на десять\n\n# Подобный оператор есть и для вычитания\ncountdown -= 3  # На каждом шаге countdown уменьшается на три\n\n# и для умножения\nmoney *= 7  # На каждом шаге money умножаются на 7\n\n# и для деления\nproblem /= 2  # На каждом шаге problem делятся пополам\n/////////////////////////////////////////////////////////////////////////\nСледующая задача: сосчитать суммарную площадь всех помещений. Принцип решения будет чем-то похож на подход в предыдущей задаче.\nДля решения этой задачи никаких сравнений не понадобится; суммировать нужно все значения списка, без исключений.\n1. Создаём переменную sum_area, к значению которой будем по очереди прибавлять значения каждого из элементов списка. Пока что значение этой переменной — ноль.\n2. В цикле перебираем все элементы списка flat, как и в прошлой задаче.\n3. Значение каждого элемента списка прибавляем к sum_area.\n4. Напечатаем сообщение, в котором укажем общую площадь квартиры.\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nflat = [\n    5.55, 22.19, 7.78, 26.86, 5.55,\n    29.84, 22.19, 5.55, 16.85, 4.52\n]\n# В переменной sum_area будем суммировать площади комнат.\n# Пока что она равна нулю.\nsum_area = 0\nfor room in flat:\n    # На каждой итерации цикла прибавляем к sum_area площадь ещё одной комнаты\n    # Запишем эту операцию через сокращённый синтаксис +=\n    sum_area += room\nprint('Общая площадь =', sum_area)\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nDepeche Mode XXI\nХватит планировок, даёшь музыку: посчитаем на Python, сколько альбомов выпустила музыкальная группа Depeche Mode в 21 веке.\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n# Список годов, в которые Depeche Mode выпускала альбомы\nyears = [\n    1981, 1982, 1983, 1984, 1986, 1987, 1990,\n    1993, 1997, 2001, 2005, 2009, 2013, 2017\n]\n# В этой переменной будем подсчитывать количество альбомов.\n# Пока что в ней ничего нет, она равна нулю.\ncount = 0\nfor year in years:\n    if year > 2000:\n        # Каждый раз загибаем по одному пальцу,\n        # обнаружив альбом, выпущенный в 21 веке.\n        count += 1   # Это то же самое, что count = count + 1\nprint('Выпущено альбомов в XXI веке:', count)\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nЗадача 1\nВ теории этого урока приведён код, который находит количество вхождений определённого значения в списке — подсчитывает количество комнат заданной площади;\nвыражение «количество вхождений» означает «сколько раз определённое значение встречается в списке или в любом другом наборе данных».\nНедостаток этого кода в том, что он размещён в теле программы, а не в функции.\nВаша задача — исправить эту ситуацию: оберните код в функцию.\n1. Объявите функцию, назовите её rooms_equal()\n2. Функция rooms_equal() должна принимать на вход два параметра:\no room_size — значение, которое функция будет искать в списке;\no room_list — имя списка, в котором будет проводиться поиск;\n3. Перенесите в функцию код, который подсчитывает количество помещений заданной площади.\n4. В коде уже подготовлен вызов функции rooms_equal(), она должна подсчитать, сколько в списке flat помещений площадью 5.55 кв.м.\nДобавьте ещё один вызов функции: пусть она сосчитает, сколько комнат площадью 9.2 кв.м в списке hut (англ. hut — «хижина»).\n////////////////////////////////////////////////////////////////////\n# Объявите функцию rooms_equal() с параметрами room_size и room_list\n...\n# Перенесите следующий код в тело функции, которую вы объявили\ncount = 0\nfor room in room_list:\n    if room == room_size:\n        count = count + 1\nprint('Комнат площадью', room_size, 'кв.м:', count)\n# Следующий код не изменяйте и не переносите в тело функции\nflat = [\n    5.55, 22.19, 7.78, 26.86, 5.55,\n    29.84, 22.19, 5.55, 16.85, 4.52\n]\nhut = [9.2, 3.5, 8.1, 2.3, 9.2, 4.2, 6.9]\nrooms_equal(5.55, flat)\n# Добавьте ещё один вызов функции rooms_equal()\n# Передайте в функцию искомую площадь - 9.2 кв.м и список hut\n...\n////////////////////////////////////////////////////////////////////\nЗадача 2\nДопишите функцию number_of_occurrences() так, чтобы она сосчитала, сколько раз в строке string встречается буква, переданная в параметр char.\nСтрока — это последовательность, как и список; строку можно точно так же перебрать в цикле по элементам (буквам и другим символам),\nнайти и пересчитать нужные элементы.\nПредыдущая задача вам поможет: она очень похожа на эту.\n////////////////////////////////////////////////////////////////////////////////////////\ndef number_of_occurrences(char, string):\n    # Здесь объявите переменную count, равную нулю.\n    # Она будет хранить количество вхождений\n    ...\n    for letter in string:\n        # Напишите условие: сравните переменные letter и char\n        # И если letter равна char - увеличивайте счётчик count на 1\n        ...\n    # Печатаем исходную строку:\n    print('Исходная строка:', string)\n    # Печатаем результат подсчётов:\n    print('Количество вхождений символа', char, 'составляет:', count)\n# Код ниже не изменяйте\nphrase = 'Не волнуйтесь, если что-то не работает. Если бы всё работало, вас бы уволили.'\n# Вызываем функцию number_of_occurrences(), чтобы она посчитала,\n# сколько раз во фразе phrase встречается буква 'е'\nnumber_of_occurrences('е', phrase)\n////////////////////////////////////////////////////////////////////////////////////////",
      "isLock": true
    },
    {
      "id": 22,
      "language": "Python",
      "title": "Урок 22. Возврат значений из функции.",
      "text": "До сих пор вы писали функции, которые печатали результаты вычислений на экран. Но обычно задача функции не сводится к печати: вычисленное в функции значение передаётся в код, и с этим значением производится ещё какая-то работа.\n\nПри производстве автомобилей в большой пресс подают лист металла — и пресс штампует капот машины. Но это ещё не финальный продукт: капот передаётся дальше по конвейеру, ведь его надо покрасить и прикрепить к корпусу автомобиля. Функция должна работать подобным образом: в неё поступает «заготовка» — аргументы, переданные при вызове, а на выход функция выдаёт какой-то результат, возвращает его в ту часть кода, откуда она была вызвана. В дальнейшей работе программа применит значение, вернувшееся из функции, для каких-то дальнейших вычислений.\n\nВозвращаемое значение указывается в теле функции после ключевого слова return. Функция calc_square() получает на вход два аргумента — длины сторон прямоугольника, вычисляет и возвращает его площадь. Запустите код в онлайн компиляторе, посмотрите, что будет выведено в терминал.\n\n/////////////////////////////////////////////////////////////////////\n# Функция для вычисления площади прямоугольника;\n# от англ. calculate, «вычислять»\ndef calc_square(side_a, side_b):\n    # Вычисляем площадь и присваиваем результат переменной result\n    result = side_a * side_b\n    # Функция возвращает значение переменной result:\n    return result\n# Вызываем функцию calc_square() с аргументами 16 и 9.\n# Значение, которое вернёт функция, будет присвоено переменной rectangle_area\nrectangle_area = calc_square(16, 9)\nprint(rectangle_area)\n/////////////////////////////////////////////////////////////////////\n\nОбратите внимание: сама функция calc_square() ничего не печатает, в ней нет вызова print(). Функция calc_square() была вызвана в строке rectangle_area = calc_square(16, 9); она произвела нужные вычисления и передала («вернула») получившееся значение в переменную rectangle_area. И это значение было напечатано уже вне функции, в основном коде программы.\n\nВернёмся к истории с квартирой: напишем небольшую программу, которая вычислит и напечатает суммарную площадь трёх жилых комнат, размеры которых нам известны: 3х5, 4х6 и 3х6 метров. Для этого пригодится та же функция calc_square().\n\n//////////////////////////////////////////////////////////////////////\ndef calc_square(side_a, side_b):\n    result = side_a * side_b\n    # Функция возвращает значение переменной result:\n    return result\n# Вызовем функцию calc_square(), передав в неё размеры первой комнаты;\n# функция вычислит площадь комнаты и вернёт её;\n# вернувшееся значение присвоим переменной room1.\nroom1 = calc_square(3, 5)\n# Вычислим и сохраним в переменную room2 площадь второй комнаты:\nroom2 = calc_square(4, 6)\n# Площадь третьей комнаты сохраним в room3:\nroom3 = calc_square(3, 6)\n# Теперь можно суммировать полученные значения и напечатать результат:\nrooms_sum = room1 + room2 + room3\nprint('Суммарная площадь комнат равна', rooms_sum, 'кв.м')\n//////////////////////////////////////////////////////////////////////\n\nЗадача 1\nДоработайте программу подсчёта тёплых дней в мае 2017 г.: допишите функцию comfort_count() так, чтобы она возвращала подсчитанное количество тёплых дней.\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\nmay_2017 = [24, 26, 15, 10, 15, 19, 10, 1, 4, 7, 7, 7, 12, 14, 17, 8, 9, 19, 21, 22, 11, 15, 19, 23, 15, 21, 16, 13, 25, 17, 19]\n# Допишите эту функцию\ndef comfort_count(temperatures):\n    count = 0\n    for temp in temperatures:\n        if 22 <= temp <= 26:\n            count += 1\n    # Функция должна вернуть значение переменной count\n    return count\n# Код ниже не изменяйте:\n# вызовем функцию comfort_count(), передадим в неё список may_2017,\n# результат работы сохраним в переменную nice_days\nnice_days = comfort_count(may_2017)\n# Напечатаем значение, сохранённое в nice_days\nprint('Количество тёплых дней в этом месяце:', nice_days)\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nЗадача 2\nПлотник Афанасий зачем-то решил построить из стекла и палок восемь одинаковых кубов; рёбра кубов будут из палок, а грани — из стекла. Ребро куба, по чертежам Афанасия, должно быть 3 метра.\n\nДопишите программу так, чтобы она печатала общую длину палок, необходимых для строительства восьми кубов. Функцию для подсчёта периметра одного куба Афанасий написал: эта функция принимает на вход длину ребра куба, а возвращает периметр куба — сумму длин всех его рёбер.\n\n• Вызовите функцию calc_cube_perimeter() с аргументом 3 и присвойте возвращаемое функцией значение переменной one_cube_perimeter. Теперь в этой переменной будет храниться периметр одного куба.\n• Вычислите суммарный периметр для восьми кубов и присвойте получившееся значение переменной full_length.\n\nВывод результата на печать уже подготовлен в коде.\n\n///////////////////////////////////////////////////////////////////////\n# Функция для вычисления периметра куба.\ndef calc_cube_perimeter(side):\n    return side * 12\n# Присвойте переменной one_cube_perimeter значение,\n# которое вернёт функция calc_cube_perimeter() с аргументом 3:\n# 3 метра - это длина ребра куба.\none_cube_perimeter = calc_cube_perimeter(3)\n# Вычислите общую длину палок, необходимых\n# для строительства 8 кубов,\n# и сохраните это значение в переменную full_length\nfull_length = one_cube_perimeter * 8\n# А теперь напечатаем результат (в этой строке ничего изменять не нужно)\nprint('Необходимый метраж палок для 8 кубов:', full_length)\n///////////////////////////////////////////////////////////////////////",
      "isLock": true
    },
    {
      "id": 23,
      "language": "Python",
      "title": "Урок 23. Вызов функции из функции.",
      "text": "Афанасий так загорелся идеей написать программу для расчёта материалов, что собрал весь код вместе, в один файл.\nЗапустите программу в онлайн компиляторе, посмотрите, чего добился Афанасий с вашей помощью.\n\n/////////////////////////////////////////////////////////////////\n# Функция для вычисления периметра куба.\ndef calc_cube_perimeter(side):\n# Вызов функции calc_cube_perimeter() с аргументом 3\none_cube_perimeter = calc_cube_perimeter(3)\nfull_length = one_cube_perimeter * 8\nprint('Необходимый метраж палок для 8 кубов:', full_length)\n# Функция для вычисления площади куба.\ndef calc_cube_area(side):\n    one_face = side * side\n    cube_area = one_face * 6\n    return cube_area\n# Вызов функции calc_cube_area() с аргументом 3\none_cube_area = calc_cube_area(3)\nfull_area = one_cube_area * 8\nprint('Необходимая площадь стекла для 8 кубов, кв.м:', full_area)\n/////////////////////////////////////////////////////////////////\n\nПрограмма работает, но в ней есть недочёты: работать с кодом неудобно, фрагменты кода повторяются:\n•\tприходится по отдельности вызывать две функции;\n•\tпри вызове этих функций в них передаётся один и тот же аргумент — длина ребра куба, 3.\nАфанасий решил, что сейчас он напишет функцию calc_cube(), которая сама будет вызывать обе эти функции и печатать калькуляцию необходимых материалов! \nТогда можно будет обойтись лишь одним вызовом.\nЧерез три часа всё было готово:\n\n///////////////////////////////////////////////////////////////////////////////////////////\n# Функция для вычисления периметра куба.\ndef calc_cube_perimeter(side):\n    return side * 12\n\n# Функция для вычисления площади куба.\ndef calc_cube_area(side):\n    one_face = side * side\n    cube_area = one_face * 6\n    return cube_area\n\n# Основная функция, которая принимает длину ребра куба\ndef calc_cube(side):\n    # Вызываем функцию, рассчитывающую периметр\n    # и передаём в неё размер куба\n    one_cube_perimeter = calc_cube_perimeter(side)\n    full_length = one_cube_perimeter * 8\n\n    # Вызываем функцию, рассчитывающую площадь стекла\n    # и передаём в неё размер куба\n    one_cube_area = calc_cube_area(side)\n    full_area = one_cube_area * 8\n\n    print('Для 8 кубов понадобится палок (м):', full_length, 'и стекла (кв.м):', full_area)\n# В результате остался лишь один вызов \"основной\" функции,\n# а она уже вызовет две вспомогательные\ncalc_cube(3) \n///////////////////////////////////////////////////////////////////////////////////////////\n\nВызов функции из другой функции — распространённый приём, это позволяет сделать код более структурированным и универсальным. \nВ программе получается одна «точка входа» — стартовый код, в который передаются все необходимые данные. \nВ программе Афанасия такой точкой входа служит функция calc_cube().\nЕсть и ещё одно преимущество: размер куба задаётся лишь в одном месте кода — при вызове calc_cube(). \nЭто уменьшает вероятность ошибки и упрощает работу с программой.\n\n\t\t\t\t\tБлочное строительство программ\nБез функций жизнь разработчика была бы беспросветной и печальной, а его код — огромным, запутанным и неуправляемым. \nФункции разделяют код на логические фрагменты, экономят силы и время, превращают программу в стройную конструкцию. \n\n\t\t\t\t\tЛомаем код: ошибка RecursionError\nНапишем простую функцию, которая перемножает два числа, переданных в аргументах, и печатает результат:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ndef multiplication(multiplier_1, multiplier_2):\n    print(multiplier_1 * multiplier_2)\n# Дальше начинается код, который расположен вне функции:\n# Python понимает это по отсутствию отступов.\n# Вызов функции multiplication()\nmultiplication(7, 6)\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nНо если в этом коде вызов функции будет отбит четырьмя отступами, как и тело функции — программа не сработает, не будет напечатано ничего.\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ndef multiplication(multiplier_1, multiplier_2):\n    print(multiplier_1 * multiplier_2)\n    multiplication(7, 8) \n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nPython увидит, что строка multiplication(7, 8) отбита четырьмя отступами и решит, что эта строка — часть тела функции. \nА значит, эта строка не будет выполнена до тех пор, пока функция не будет вызвана. А вызова в коде (вне функции) нет.\nНо если всё же вызвать эту функцию, она начнёт вызывать сама себя. Программа зациклится и появится ошибка RecursionError.\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ndef multiplication(multiplier_1, multiplier_2):\n    print(multiplier_1 * multiplier_2)\n    multiplication(7, 8)\nmultiplication(5, 6) \n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nМожете запустить этот код, но будьте готовы к тому, что вывод в консоль будет о-о-о-очень длинным. Однако ничего не сломается.\nПри первом вызове функция напечатает 30, а затем закрутится в бесконечном повторении, вызывая сама себя при каждом новом вызове. \nПодобная рекурсия может возникнуть и при вызове функции из функции: func_one() вызывает func_two(), а func_two(), в свою очередь вызывает func_one():\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ndef func_one():\n    print('Раз')\n    func_two()\n\ndef func_two():\n    print('Два')\n    func_one()\n\nfunc_one() # Вызываем функцию func_one() \n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nPython умеет обрывать такие циклы после определённого количества итераций, при этом он выбрасывает ошибку RecursionError \nУвидите эту ошибку — проверьте:\n•\tне вызывается ли какая-то функция сама из себя;\n•\tвсё ли в порядке с отступами — именно они определяют начало и конец тела функции;\n•\tне вызывают ли функции друг друга «по кругу».\n\n\t\t\t\t\tЗадача 1\nПрограмма делает всё, что требовалось Афанасию: рассчитывает количество материала, необходимое для строительства восьми кубов. \nА если понадобится сделать три куба или десять? \nСделайте программу более универсальной, измените её так, чтобы в неё можно было передать не только сторону куба, но и количество кубов. \nДля этого понадобится второй аргумент в функции calc_cube()\n•\tИзмените строку, в которой объявляется функция calc_cube(): добавьте второй аргумент (назовите его, например, amount).\n•\tВ тех строках функции calc_cube(), где используется число кубов, используйте значение переменной amount.\n•\tВ строке, которую печатает функция, выводится количество кубов; там тоже потребуется вывести значение переменной amount.\n\n//////////////////////////////////////////////////////////////////////////////////////////////////\n# Функция для вычисления периметра кубов.\ndef calc_cube_perimeter(side):\n    return side * 12\n# Функция для вычисления площади кубов.\ndef calc_cube_area(side):\n    one_face = side * side\n    cube_area = one_face * 6\n    return cube_area\n# Дополните объявление функции: \n# теперь должна принимать два параметра -\n# длину ребра куба и количество кубов.\ndef calc_cube(side, ...):\n    # Вызываем функцию, рассчитывающую периметр\n    # и передаём в неё размер куба\n    one_cube_perimeter = calc_cube_perimeter(side)\n    # Здесь вместо многоточия должна стоять переменная, \n    # хранящая количество кубов, переданное во втором аргументе.\n    full_length = one_cube_perimeter * ...\n    # Вызываем функцию, рассчитывающую площадь стекла\n    # и передаём в неё размер куба\n    one_cube_area = calc_cube_area(side)\n    # Здесь вместо многоточия должна стоять переменная, \n    # хранящая количество кубов, переданное во втором аргументе.\n    full_area = one_cube_area * ...\n    # В этой строке замените многоточие на переменную, хранящую количество кубов\n    print('Для', ..., 'кубов понадобится палок (м):', full_length, 'и стекла (кв.м):', full_area)\n# Для проверки работы кода вызываем функцию с двумя аргументами: \n# 3 - это размер ребра куба,\n# 2 - это необходимое количество кубов\ncalc_cube(3, 2)\n//////////////////////////////////////////////////////////////////////////////////////////////////",
      "isLock": true
    },
    {
      "id": 24,
      "language": "Python",
      "title": "Урок 24. Множества.",
      "text": "Коллекции в Python\nПеречень всех музыкантов этой группы вы уже сохраняли в списке — структуре, состоящей из нескольких элементов; \nсписок list — это один из типов данных в Python.\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n# Объявляем список bremen_musicians \nbremen_musicians = ['Трубадур', 'Кот', 'Пёс', 'Осёл', 'Петух'] \n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nПомимо списков в Python есть и другие типы данных, которые могут хранить набор элементов. Такие типы данных называют коллекции. \n\n\t\t\t\t\tКрасивый код\nЛюбые коллекции можно записывать в одну строку. С технической точки зрения это нормально и не вызовет проблем в работе программы. \nНо читать такой код неудобно, строка может оказаться очень длинной:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nconcert_songs = ['Ничего на свете лучше нету', 'Мы к вам заехали на час', 'Рок-колыбельная', 'Луч Солнца Золотого', 'Куда ты, тропинка, меня завела', 'А как известно, мы народ горячий'] \n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nДля удобства чтения кода коллекции записывают построчно: каждый элемент — на отдельной строке. На работу кода это не влияет, а выглядит лучше:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nconcert_songs = [\n    'Ничего на свете лучше нету',\n    'Мы к вам заехали на час',\n    'Рок-колыбельная',\n    'Луч Солнца Золотого',\n    'Куда ты, тропинка, меня завела',\n    'А как известно, мы народ горячий'\n] \n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\n\t\t\t\t\tМножества (set)\nОдна из разновидностей коллекций в Python — это множества, тип данных set. По структуре множества очень похожи на списки: \nв коде они записываются как перечень элементов, разделённых запятой. Элементы множества замыкаются в фигурные скобки { }.\nОдно из важных отличий множества от других коллекций — все элементы множества должны быть уникальны, в множестве не может быть двух одинаковых элементов.\nВот песни, которые музыканты планируют исполнить на площади перед дворцом короля. Названия песен собраны в сет: перечень обрамлён фигурными скобками.\nЗапустите код в онлайн компиляторе несколько раз, посмотрите, что напечатает программа.\n\n/////////////////////////////////////////////////////////////////////\nconcert_songs = {\n    'Ничего на свете лучше нету',\n    'Мы к вам заехали на час',\n    'Рок-колыбельная',\n    'Луч Солнца Золотого',\n    'Ничего на свете лучше нету',\n    'Куда ты, тропинка, меня завела',\n    'А как известно, мы народ горячий'\n}\n# Выясним, к какому типу данных принадлежит переменная concert_songs\n# для этого есть встроенная в Python функция type()\nprint(type(concert_songs))\n# Напечатаем содержимое переменной concert_songs\nprint(concert_songs)\n/////////////////////////////////////////////////////////////////////\n\nКоманда print(type(concert_songs)) вывела в терминал строку <class 'set'>. Проверка подтверждает: тип переменной concert_songs — set. \nПесня «Ничего на свете лучше нету» в исходном коде упомянута дважды, но на печать она выводится лишь один раз: \nPython автоматически удаляет из множества дубликаты, оставляя лишь уникальные значения.\nНо что происходит с порядком вывода элементов? При каждом запуске порядок отличается от предыдущего! Со списками такого не было.\nЭто ещё одна особенность сетов: в памяти компьютера элементы сета хранятся в неупорядоченном виде и выводятся в случайном порядке.\nИз этой особенности следует практический вывод: к элементу сета нельзя обратиться по порядковому номеру, \nпо индексу — ведь один и тот же индекс будет указывать то на один элемент, то на другой.\nЗапустите код в онлайн компиляторе, посмотрите, что будет при обращении по индексу к элементу списка и что случится, \nесли обратиться по индексу к элементу множества.\n\n//////////////////////////////////////////////////////////////\n# Объявляем список bremen_musicians \nbremen_musicians = ['Трубадур', 'Кот', 'Пёс', 'Осёл', 'Петух']\n# Обращаемся к элементу по индексу\nprint(bremen_musicians[1])\n# Будет напечатано: Кот\n# Объявим множество songs (фигурные скобки!)\nsongs = {\n    'Ничего на свете лучше нету',\n    'Мы к вам заехали на час',\n    'Рок-колыбельная'\n}\n# Обращаемся к элементу по индексу\nprint(songs[2])\n# \"Ошибка: set не поддерживает индексы\"\n//////////////////////////////////////////////////////////////\n\n\t\t\t\t\tПреобразование списка в множество: функция set()\nБродячие музыканты любят свою публику, и за несколько дней до концерта Кот и Осёл опросили горожан и выяснили, \nкакие песни зрители хотят услышать на концерте. \nПосле опроса Кот написал небольшую программу: объявил в коде список songs_list и внёс в него все полученные ответы. \nОтветы горожан, конечно же, повторялись, поэтому каждая песня встречается в списке несколько раз.\nЧтобы в перечне песен остались только уникальные названия \n(не исполнять же «Луч солнца золотого» четыре раза за концерт!) — можно преобразовать список в множество, \nдля этого в Python есть встроенная функция set(). При таком преобразовании Python автоматически выбросит из перечня дубликаты: \nв сете не может быть одинаковых элементов.\nЗапустите код в онлайн компиляторе, посмотрите, сколько же песен, в результате, исполнят бременские музыканты.\n\n///////////////////////////////////////////////\nsongs_list = [\n    'Мы к вам заехали на час',\n    'А как известно, мы народ горячий',\n    'Куда ты, тропинка, меня завела',\n    'Луч Солнца Золотого',\n    'Рок-колыбельная',\n    'Рок-колыбельная',\n    'Куда ты, тропинка, меня завела',\n    'А как известно, мы народ горячий',\n    'Луч Солнца Золотого',\n    'Ничего на свете лучше нету',\n    'А как известно, мы народ горячий',\n    'Луч Солнца Золотого',\n    'Мы к вам заехали на час',\n    'Ничего на свете лучше нету',\n    'Куда ты, тропинка, меня завела',\n    'Луч Солнца Золотого'\n]\n# Преобразуем список songs_list в сет\n# и запишем этот сет в переменную unique_songs:\nunique_songs = set(songs_list)\nprint(unique_songs)\n///////////////////////////////////////////////\n\n\t\t\t\t\tЦиклом по множеству\nМножество содержит набор элементов, но получить к ним доступ по индексу невозможно. \nНо какой смысл хранить данные без возможности их извлечь и обработать?\nРазумеется, выход есть: любую коллекцию можно перебрать в цикле, а множество — это коллекция. \nОбъявление цикла и работа с ним для списков и множеств ничем не отличаются. \nНо порядок, в котором будут обработаны элементы множества, непредсказуем, ведь множество — неупорядоченная коллекция.\nНапечатаем афишу. Названия песен будут напечатаны в случайном порядке, ведь unique_songs — это множество. \nНо такая непредсказуемость внесёт некоторую интригу в программу концерта. \nВыполните код несколько раз, убедитесь, что порядок песен будет отличаться при каждом запуске программы.\n\n////////////////////////////////////////////////////////////////////\nunique_songs = {\n    'Рок-колыбельная',\n    'Ничего на свете лучше нету',\n    'Мы к вам заехали на час',\n    'А как известно, мы народ горячий',\n    'Луч Солнца Золотого',\n    'Куда ты, тропинка, меня завела'\n}\n# Сначала напечатаем заголовок афиши\nprint('Только один концерт! Проездом из Бремена в Рио-де-Жанейро!')\nprint('БРЕМЕНСКИЕ МУЗЫКАНТЫ!')\n# Объявляем цикл\nfor song in unique_songs:\n    print(song)\n# А эта строка выполнится после того,\n# как цикл закончит работу\nprint('Не опаздывайте, начало в 19:00')\n////////////////////////////////////////////////////////////////////\n\n\t\t\t\t\tЗадача 1\nПрограмма-помощник Анфиса собрала в единый список (list) названия городов, где живут ваши друзья. Города в списке повторяются. \nСоздайте коллекцию, в которой названия городов не будут повторяться: преобразуйте список cities в множество unique_cities. \nЗатем построчно напечатайте элементы unique_cities. Перед названием каждого города поставьте дефис и пробел; должно получиться что-то вроде\n- Акапулько\n- Барнаул\n- Верона \n\n/////////////////////////////////////////\ncities = [\n    'Вологда',\n    'Чебоксары',\n    'Тольятти',\n    'Москва',\n    'Бремен',\n    'Санкт-Петербург',\n    'Новороссийск',\n    'Челябинск',\n    'Вологда',\n    'Новосибирск',\n    'Челябинск',\n    'Санкт-Петербург',\n    'Москва',\n    'Новосибирск'\n]\nunique_cities = # Напишите здесь свой код\n/////////////////////////////////////////\n\n\t\t\t\t\tЗадача 2\nДля каждого города из множества unique_cities напечатайте на экран сообщение У меня есть друг в городе <название_города>. \nВ решении этой задачи не обойтись без цикла.\n\n////////////////////////////\ncities = [\n    'Вологда',\n    'Чебоксары',\n    'Тольятти',\n    'Москва',\n    'Бремен',\n    'Санкт-Петербург',\n    'Новороссийск',\n    'Челябинск',\n    'Вологда',\n    'Новосибирск',\n    'Челябинск',\n    'Санкт-Петербург',\n    'Москва',\n    'Новосибирск'\n]\nunique_cities = set(cities)\n# Напишите ваш код здесь\n////////////////////////////",
      "isLock": true
    },
    {
      "id": 25,
      "language": "Python",
      "title": "Урок 25. Операции с множествами.",
      "text": "Неплохим примером множества может быть плейлист: он состоит из отдельных элементов (названий песен) и элементы в нём не должны повторяться. \nИ любой плейлист постоянно хочется изменить: расширить, объединить или сравнить с другим плейлистом. Посмотрим, как это делается в Python.\n\n\t\t\t\t\tДобавление нового элемента в множество\nЧтобы добавить новый элемент в множество, к нему применяют метод add().\nМетод — это разновидность функции, мини-программа. Однако, в отличие от функций, метод применяется к объекту, например — к строке, к числу или к множеству. \nУ строк — свои методы, у чисел — свои, у множеств — свои. \nМетоды применяются к конкретным объектам и выполняют с ними какие-то действия. Чтобы применить метод к какому-то объекту, \nв коде записывают имя объекта, ставят точку и после неё пишут название метода с круглыми скобками (в скобках могут быть аргументы, как у функции): \nобъект.метод(аргумент).\nМетод add() в качестве аргумента принимает значение, которое нужно добавить в множество. Этот метод может добавить лишь один элемент; \nчтобы добавить несколько элементов — нужно вызвать метод add() несколько раз с разными аргументами.\nПрименим метод add() к объекту playlist. Аргументом будет строка 'Thunderstruck'; метод add() добавит новый элемент в множество playlist.\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nplaylist = {\n    'Venus',\n    'Yesterday',\n    'Fireball',\n    'Time',\n    'Poison'\n}\n\nplaylist.add('Thunderstruck')\nprint(playlist)\n# Будет напечатано: \n# {'Yesterday', 'Fireball', 'Thunderstruck', 'Poison', 'Venus', 'Time'}\n# Элементы множеств никогда не соблюдают порядок! \n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\n\t\t\t\t\tОбъединение двух множеств\nМножества в Python можно объединять. Например, можно составить из двух новогодних плейлистов один общий, да так, чтобы ни одна песня не повторялась.\nМетод union() применяют для объединения двух множеств. Метод применяется к одному множеству, а в аргументе передаётся второе.\nВ результате будет создано новое, третье множество (а оба исходных останутся такими, как были).\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nplaylist_1 = {'Три белых коня', 'Happy new year', 'Снежинка'}\nplaylist_2 = {'Last christmas', 'Снежинка', 'Happy new year'}\nplaylist_3 = playlist_1.union(playlist_2)\nprint(playlist_3)\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\n\t\t\t\t\tПоиск различий в двух множествах\nЕсли нужно найти песни, которые присутствуют в одном плейлисте, но отсутствуют во втором — поможет метод difference().\nМетод set_1.difference(set_2) вернёт новое множество, оно будет содержать только те элементы, которые присутствуют в set_1, но отсутствуют в set_2; \nэто похоже на «вычитание»: set_1 - set_2.\nНи одно из исходных множеств не изменится.\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nplaylist_1 = {'Голубой вагон', 'Облака', 'Yesterday', 'Наше лето'}\nplaylist_2 = {'Наше лето', 'Голубой вагон', 'Облака'}\nplaylist_3 = playlist_1.difference(playlist_2)\nprint(playlist_3)\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\n\t\t\t\t\tПоиск одинаковых элементов в двух множествах\nМожно найти пересечение двух множеств, то есть элементы, которые есть и в первом, и во втором множестве.\nПосмотрим на списки фильмов, просмотренных двумя людьми и определим, в чём их вкусы совпадают. \nДля этого применим метод intersection(), он вернёт новое множество, в котором будут храниться «пересекающиеся» элементы.\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfilms_1 = {'Форсаж', 'Достучаться до небес', 'Мстители: война бесконечности'}\nfilms_2 = {'Мстители: война бесконечности', 'Форсаж', 'Матрица'}\nfilms_3 = films_1.intersection(films_2)\nprint(films_3)\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\n\t\t\t\t\tЗадача 1\nНаучим программу играть в города. У неё в памяти хранится два перечня городов: \n•\tв множестве all_cities хранятся все города, которые она знает,\n•\tв множестве used_cities — города, которые уже были названы в игре, их уже нельзя использовать.\nНаучите программу получать перечень городов, которые ещё не были названы в игре.\nВ коде объявлена функция: def print_valid_cities(...), допишите её. \nОна должна:\n•\tпринять на вход множества all_cities и used_cities;\n•\tсоздать множество городов, которые ещё не использовались в игре; для этого функция должна найти разницу множеств all_cities и used_cities;\n•\tпострочно напечатать элементы получившегося множества на экране.\n\n///////////////////////////////////////////////////////////////////\ndef print_valid_cities(...):\n    ...\n    # Вместо этого многоточия напишите код функции, она должна\n    # принимать и обрабатывать аргументы all_cities и used_cities,\n    # а затем печатать результат в нужном формате\nall_cities = {\n    'Абакан',\n    'Астрахань', \n    'Бобруйск', \n    'Калуга',\n    'Караганда',\n    'Кострома',\n    'Липецк', \n    'Новосибирск'\n}\nused_cities = {'Калуга', 'Абакан' , 'Новосибирск'}\nprint_valid_cities(all_cities, used_cities)\n///////////////////////////////////////////////////////////////////",
      "isLock": true
    },
    {
      "id": 26,
      "language": "Python",
      "title": "Урок 26. Словари.",
      "text": "В предыдущих уроках данные хранились в списках или множествах: под одним именем записана целая коллекция значений, это удобно и компактно. \nНо вот, например, задача: нужно научить программу английскому языку. Для этого требуется создать несложный русско-английский словарик: \nсохранить в программе несколько английских слов и переводы к ним. \nМожно создать два списка и сопоставлять их:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nrussian_words = ['рука', 'нога', 'хвост', 'питон', 'бэкенд-разработчик']\nenglish_words = ['hand', 'leg', 'tail', 'python', 'backend-developer'] \n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nНо было бы удобно хранить не просто слова по отдельности, а пары — русское слово и его перевод:\n•\tрука — hand,\n•\tнога — leg,\n•\tхвост — tail,\n•\tпитон — python,\n•\tбэкенд-разработчик — backend developer.\nВ Python есть тип данных словарь, dict, он хранит информацию именно в такой структуре.\n\n\t\t\t\t\tСловарь — это коллекция, набор элементов.\nКаждый элемент словаря состоит из двух частей, между этими частями ставится двоеточие: первая часть элемента называется ключ, вторая часть — значение. \nЭлементы словаря замыкают в фигурные скобки {…}, а между собой элементы разделяют запятой.\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nenglish = {\n    'рука': 'hand', # Первый элемент словаря (да, в каждом элементе две части!)\n    'нога': 'leg',  # Второй элемент словаря\n    'хвост': 'tail',  # Третий элемент\n    'питон': 'python',  # Четвёртый элемент\n    'бэкенд-разработчик': 'back-end developer'  # Пятый элемент\n} \n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nЕсли представить себе шкаф с подписанными ячейками (этот шкаф и будет словарём), то надпись на ячейке — это ключ, а то, что лежит в ячейке — это значение.\nВ словаре english русские слова — это ключи, а их переводы на английский — значения.\n\n\t\t\t\t\tДоступ к значению словаря по ключу\nЧтобы получить из словаря определённое значение — в коде указывают ключ, значение которого нужно получить; это называется «доступ по ключу». \nТочно так же в шкафу можно отыскать ячейку с нужной надписью и достать из неё содержимое:\n\n— А что у нас лежит в ячейке с надписью \"money\"?\n— Золотая монета!\n— А в ячейке \"big animal\"?\n— Слон, разумеется! \n\nЭлементы словаря можно записать в одну строку, но лучше разбить словарь построчно. \nНа выполнение кода это никак не повлияет, а разработчикам будет гораздо приятнее читать форматированный код, а не бесконечную строку.\nЗапустите программу в онлайн компиляторе и посмотрите, что будет напечатано; в коде запрашивается значение по ключу 'рука'. \nДоступ по ключу выглядит очень похоже на доступ по индексу в списках: пишется название словаря и, в квадратных скобках, необходимый ключ.\nПоэкспериментируйте: например, измените код так, чтобы программа напечатала значение 'backend developer'.\n\n/////////////////////////////////////////////\nenglish = {\n    'рука': 'hand',\n    'нога': 'leg',\n    'хвост': 'tail',\n    'питон': 'python',\n    'бэкенд-разработчик': 'backend developer'\n}\n# Доступ по ключу: как по-английски рука?\nprint(english['рука'])\n/////////////////////////////////////////////\n\n\t\t\t\t\tУникальность ключей в словаре\nВ словаре не может быть двух одинаковых ключей. Именно это свойство словаря позволяет безошибочно получать доступ к каждому значению: \nключ — это уникальный адрес для доступа к значению.\nЗначением в словаре может быть вообще что угодно: числа, строки, булевы значения True/False, списки или даже другие словари. \nЗначения словаря не обязаны быть уникальными и могут повторяться.\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ndump = {\n    1: 'единица',               # Ключ - число, значение - строка.\n    'земляника': 'ягода',       # И ключ, и значение - строки.\n    'помидор': 'ягода',         # Значение 'ягода' - не уникально. Так можно.\n    False: 0,                   # Ключ - булево значение, значение - число.\n    'лук': ['овощ', 'оружие'],  # Ключ - строка, значение - список.\n    # Ключ - строка, а значение - словарь. Так тоже можно!\n    'англо-русский словарь': {'рука': 'hand', \n                              'нога': 'leg', \n                              'бэкенд-разработчик': 'back-end developer'\n                               },    \n}\n\nprint(dump['лук'])\n# Будет напечатано ['овощ', 'оружие'] \n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nЕсли присмотреться, то становится заметно, что ключи словаря ведут себя как множество (они уникальны в пределах словаря), \nа значения чем-то сходны со списком. Как будто попарно склеили элементы множества и списка — и получился словарь.\n\n\t\t\t\t\tУправление словарём\nВ любом элементе словаря можно заменить существующее значение на новое — так же, как из ячейки шкафа можно выбросить старое содержимое и положить туда новое. \nДля замены значения нужно обратиться к элементу по ключу и присвоить ему новое значение. В общем виде присвоение нового значения будет выглядеть так: \n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nимя_словаря[ключ] = новое_значение\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nВ исходном словаре ключу 'рука' соответствует значение 'hand' — заменим его на 'arm'. Прочтите код и запустите его в онлайн компиляторе: посмотрите, что получится.\n\n///////////////////////////////////////////////////\nenglish = {\n    'рука': 'hand',\n    'нога': 'leg',\n    'хвост': 'tail',\n    'питон': 'python',\n    'бэкенд-разработчик': 'backend developer'\n}\n# Элементу с ключом 'рука' присвоим новое значение:\nenglish['рука'] = 'arm'\nprint(english['рука'])\n///////////////////////////////////////////////////\n\nВсе значения словаря можно извлечь и собрать в одну коллекцию. Для этого у словаря есть метод values():\n\n////////////////////////////////////////////////////////////\n# Словарь, в котором хранятся начертания букв и их названия:\nold_letters = {\n    'ять': 'Ѣ',\n    'юс малый': 'Ѧ',\n    'юс большой': 'Ѫ'}\nprint(old_letters.values())\n# Будет напечатан список значений словаря:\n# dict_values(['Ѣ', 'Ѧ', 'Ѫ'])\n////////////////////////////////////////////////////////////\n\nПодобным образом можно получить и коллекцию ключей словаря, для этого есть метод keys():\n\n//////////////////////////////////////////////////////////////////////////\nfavorite_songs = {\n    'Тополиный пух': 'Иванушки international',\n    'Город золотой': 'Аквариум',\n    'Звезда по имени Солнце': 'Кино'\n}\nprint(favorite_songs.keys()) \n# Будет напечатан список ключей словаря:\n# dict_keys(['Тополиный пух', 'Город золотой', 'Звезда по имени Солнце'])\n//////////////////////////////////////////////////////////////////////////\n\nМетод values() возвращает коллекцию типа dict_values(), а метод keys() — коллекцию типа dict_keys(). Эти коллекции похожи на списки; \nих можно преобразовать в списки или в множества — и работать с ними.\n\n//////////////////////////////////////////////\nenglish = {\n    'рука': 'hand',\n    'нога': 'leg',\n    'хвост': 'tail',\n    'питон': 'python',\n    'бэкенд-разработчик': 'backend developer'\n}\n# Собираем ключи словаря в коллекцию\n# и преобразуем эту коллекцию в список:\nwords_ru = list(english.keys())\n# Собираем значения словаря в коллекцию\n# и преобразуем эту коллекцию в список:\nwords_en = list(english.values())\n# Печатаем списки:\nprint(words_ru)\nprint(words_en)\n//////////////////////////////////////////////\n\n\t\t\t\t\tПреобразование словаря в список или сет\nПреобразовать в множество или в сет можно не только коллекцию ключей или значений словаря, но и словарь целиком:\n•\tфункция set(имя_словаря) преобразует словарь в множество;\n•\tфункция list(имя_словаря) превратит словарь в список.\nНо в таких преобразованиях есть особенность: множество или список, которые получатся в результате, \nбудут включать только ключи словаря, а значения будут проигнорированы. \n\n\t\t\t\t\tСоздание пустых словарей и их заполнение\nВ момент создания словаря необязательно сразу создавать ключи и их значения. Можно сперва создать пустой словарь, а позднее — наполнить его содержимым. \nСоздание нового элемента в словаре (неважно, есть ли уже в словаре элементы или он совсем пуст) выглядит точно так же, как редактирование значения:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nимя_словаря[новый_ключ] = новое_значение\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nПри выполнении такого кода в словаре будет создан новый элемент новый_ключ: новое_значение. \nНо если запрошенный ключ уже есть в словаре — новый элемент не будет создан: будет изменено значение в элементе с запрошенным ключом.\nВот функция, которая добавляет в словарь название песни и её рейтинг:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfavourites_songs_and_ratings = {}\ndef add_favourite_song(song_name, rank):\n    favourites_songs_and_ratings[song_name] = rank\n# Словарь пока что пуст:\nprint('Первый вывод на печать: ', favourites_songs_and_ratings)\nadd_favourite_song('Гражданская Оборона - Моя оборона', 5)\n# А здесь словарь уже обновлен и не пуст:\nprint('Второй вывод на печать: ', favourites_songs_and_ratings)\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nМожно воспринимать пустые словари как сумку для похода в магазин: в неё можно что-то положить, но необязательно, чтобы в ней что-то лежало с самого начала.\n\n\t\t\t\t\tЗадача 1\nНаучим программу хранить в словаре записи о друзьях и получать к ним доступ по ключу.\nДопишите программу так, чтобы она напечатала название города, в котором живёт Ваня.\n\n////////////////////////\nfriends =  {\n    'Ваня': 'Омск',\n    'Соня': 'Москва',\n    'Дима': 'Челябинск'\n}\n# Ваш код здесь\n////////////////////////\n\nЗадача 2\nВ Омск к Ване уже не съездить, опоздали: он сменил работу и переехал в Оренбург. Замените значение элемента с ключом 'Ваня' на 'Оренбург'.\n\n//////////////////////////////////////////////////////////////\nfriends =  {\n    'Ваня': 'Омск',\n    'Соня': 'Москва',\n    'Дима': 'Челябинск'\n}\n# Ваш код здесь\nprint('Ваня теперь живёт в славном городе ' + friends['Ваня'])\n//////////////////////////////////////////////////////////////",
      "isLock": true
    },
    {
      "id": 27,
      "language": "Python",
      "title": "Урок 27. Расширение словаря.",
      "text": "Программа продолжает изучать английский язык, и ей необходимо расширять словарный запас. Русско-английский словарь нужно пополнять.\nСделать это можно несколькими способами.\nДобавление одного элемента\nДля добавления нового элемента можно применить доступ по ключу: объявить новый ключ словаря и присвоить ему значение.\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nenglish = {\n    'рука': 'arm',\n    'нога': 'leg',\n    'хвост': 'tail',\n    'питон': 'python',\n    'бэкенд-разработчик': 'back-end developer'\n}\n\n# Создаём новый элемент словаря через доступ по ключу\nenglish['голова'] = 'head'\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nПо записи в коде этот способ похож на замену значения для определённого ключа в словаре:\nименно так в прошлом уроке вы переселили Серёгу из Омска в Оренбург.\nРазница лишь в том, что\n• если вызван существующий в словаре ключ — его значение будет заменено;\n• если вызван ключ, которого нет в словаре — будет создан новый элемент словаря.\nЕсли добавить в словарь несколько элементов с одинаковыми ключами, но разными значениями — в словаре появится лишь один элемент с этим ключом,\nа его значением будет последнее из добавленных значений.\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nenglish = {\n    'рука': 'arm',\n    'нога': 'leg',\n    'хвост': 'tail',\n    'питон': 'python',\n    'бэкенд-разработчик': 'back-end developer',\n    'голова': 'head'\n}\n# Создаём несколько новых элементов словаря с одинаковым ключом\nenglish['гриф'] = 'vulture'  # Будет создан элемент с ключом 'гриф'.\nenglish['гриф'] = 'neck'  # Значение под ключом 'гриф' будет заменено.\nenglish['гриф'] = 'stamp'  # Значение под ключом 'гриф' будет ещё раз заменено.\nprint(english)\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nОдновременное добавление нескольких элементов\nУ словарей есть метод update(), он позволяет объединить два словаря, то есть добавить в один словарь элементы другого.\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nenglish = {\n    'рука': 'arm',\n    'нога': 'leg',\n    'хвост': 'tail',\n    'питон': 'python',\n    'бэкенд-разработчик': 'back-end developer',\n    'голова': 'head'\n}\n# Объявим новый словарь\nnew_words = {'мозг': 'brain', 'логика': 'logic'}\n# Добавим в словарь english элементы словаря new_words\nenglish.update(new_words)\n# Посмотрим, что теперь хранится в словаре english\nprint(english)\n# Заодно выясним, что произошло со словарём new_words\nprint(new_words)\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nЗадача 1\nДобавьте в словарь friends ещё две пары ключ-значение, просто дописав их в объявление словаря. Имена друзей и города, в которых они живут, придумайте сами.\nПосле этого напечатайте на экране словарь friends.\n\n//////////////////////\n\nfriends =  {\n    'Ваня': 'Омск', \n    'Соня': 'Москва', \n    'Дима': 'Челябинск'\n}\n\n//////////////////////\n\nЗадача 2\nДобавьте в словарь friends новый элемент посредством доступа по ключу. Пусть друга зовут Даниил, а его городом будет Санкт-Петербург.\nНапечатайте на экране словарь friends.\n\n/////////////////////////////////////////////////////\n\nfriends = {\n    'Ваня': 'Омск',\n    'Соня': 'Москва',\n    'Дима': 'Челябинск',\n    'Айгуль': 'Казань', \n    'Алёна': 'Белгород'\n}\n# Через доступ по ключу добавьте новый элемент словаря \n# с ключом 'Даниил' и значением 'Санкт-Петербург'\n\n# Напечатайте словарь friends \n\n//////////////////////////////////////////////////////",
      "isLock": true
    },
    {
      "id": 28,
      "language": "Python",
      "title": "Урок 28. Перебор элементов словаря.",
      "text": "Словарь — отличная структура для хранения данных, но чтобы работать с этими данными — надо извлечь их из словаря.\nПолучить отдельный элемент — не проблема: доступ по ключу вам уже знаком. А как поступить, если надо получить все ключи или все значения?\nСоздадим словарь, который будет хранить список песен. Ключами этого словаря будут названия песен, а значениями — названия групп или имена исполнителей.\nПолучите из словаря значения для ключей 'Тополиный пух' и 'Space Oddity' и напечатайте их.\n\n/////////////////////////////////////////////////////////////////\n/favorite_songs = {\n    'Тополиный пух': 'Иванушки international',\n    'Город золотой': 'Аквариум',\n    'Звезда по имени Солнце': 'Кино',\n    'Space Oddity': 'David Bowie',\n    'Рыба': 'Аквариум',\n    'Серенада Трубадура': 'Муслим Магомаев',\n}\nprint(...)  # Здесь напечатайте значение для ключа 'Тополиный пух'\nprint(...)  # А здесь - значение для ключа 'Space Oddity'\n/////////////////////////////////////////////////////////////////\n\nСловари, как и другие коллекции, можно перебрать в цикле for...in.\nОбработка списков вам уже знакома: каждый элемент списка по очереди передаётся в переменную и значение переменной обрабатывается в теле цикла.\nИ эта мельница крутится до тех пор, пока не переберёт все элементы списка.\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n/bremen_musicians = ['Кот', 'Пёс', 'Трубадур', 'Осёл', 'Петух']\nfor musician in bremen_musicians:\n    print(musician)\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nСловари в цикле обрабатываются по тому же принципу, но каждый элемент словаря состоит из двух частей, и поэтому при объявлении цикла следует указать,\nчто надо перебрать: только ключи, только значения, или и то, и другое.\nВ объявлении цикла к словарю favorite_songs применён метод items().\nЭтот метод извлекает из каждого элемента словаря ключ и значение и передаёт их в переменные song и performer.\nИмена для этих переменных разработчик может выбирать на свой вкус, они могут быть любыми;\nдля читаемости кода их часто именуют key (англ. «ключ») и value (англ. «значение»).\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n/favorite_songs = {\n    'Тополиный пух': 'Иванушки international',\n    'Город золотой': 'Аквариум',\n    'Звезда по имени Солнце': 'Кино',\n    'Space Oddity': 'David Bowie',\n    'Рыба': 'Аквариум',\n    'Серенада Трубадура': 'Муслим Магомаев',\n}\nfor song, performer in favorite_songs.items():\n    print('Песню ' + song + ' исполняет ' + performer)\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nКлючи — отдельно, значения — отдельно\nПри обработке словаря в цикле не обязательно извлекать и ключ, и значение каждого элемента. Можно перебрать только ключи словаря или только его значения;\nдля этого есть методы keys() и values().\nПроцесс перебора ключей словаря в цикле называют «итерировать по ключам»; перебирать значения словаря — «итерировать по значениям».\nЕсли в цикле применён метод keys() или values(), то нужно объявлять только одну переменную цикла:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n/favorite_songs = {\n    'Тополиный пух': 'Иванушки international',\n    'Город золотой': 'Аквариум',\n    'Звезда по имени Солнце': 'Кино',\n    'Space Oddity': 'David Bowie',\n    'Рыба': 'Аквариум',\n    'Серенада Трубадура': 'Муслим Магомаев',\n}\n# Извлечём и напечатаем только значения (values) каждого элемента\nfor singer in favorite_songs.values():\n    print('Доктор, я больше не могу слушать исполнителя ' + singer)\n# А в этом цикле извлечём и напечатаем только ключи (keys) словаря\nfor music in favorite_songs.keys():\n    print('Доктор, я каждый день по три раза слушаю песню ' + music)\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nПо умолчанию Python для итерации по словарю использует ключи. Поэтому можно итерироваться по ключам без метода keys().\nЕсли при объявлении цикла после названия словаря не указать метод — цикл будет перебирать ключи словаря.\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n/favorite_songs = {\n    'Тополиный пух': 'Иванушки international',\n    'Город золотой': 'Аквариум',\n    'Звезда по имени Солнце': 'Кино',\n    'Space Oddity': 'David Bowie',\n    'Рыба': 'Аквариум',\n    'Серенада Трубадура': 'Муслим Магомаев',\n}\nfor music in favorite_songs:\n    print(music + ' - хорошая песня')\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nЗадача 1\nНаучите программу собирать словарь friends из двух списков.\nВ коде приготовлены два списка:\n• friends_names, имена друзей;\n• friends_cities — города, где живут друзья.\nСписки соответствуют друг другу: friends_names[0] живёт в городе friends_cities[0].\nЗаполните элементами словарь friends (он уже объявлен в коде). Ключом каждого элемента должно быть имя друга, значением — город, в котором он живёт.\nДля этого в цикле создайте элементы словаря из элементов списков с одинаковыми индексами.\nДля проверки напечатайте на экран сообщение 'Лена живёт в городе <город>', используя доступ по нужному ключу в словаре friends.\n\n///////////////////////////////////////////////////////////////////////////////\n/friends_names = ['Аня', 'Коля', 'Лёша', 'Лена', 'Миша']\n/friends_cities = ['Владивосток', 'Красноярск', 'Москва', 'Обнинск', 'Чебоксары']\n/# Объявлен пустой словарь, его нужно будет наполнить элементами,\n/# каждый из которых составлен по схеме 'имя: город'\n/friends =  {}\n/# Допишите ваш код сюда\n/for i in ...:\n    ...\nprint(...)\n///////////////////////////////////////////////////////////////////////////////\n\nЗадача 2\nНапечатайте о каждом из друзей такое сообщение\n'<имя_друга> живёт в городе <название_города>'.n\n///////////////////////////////\n/friends =  {\n    'Серёга': 'Омск',\n    'Соня': 'Москва',\n    'Дима': 'Челябинск',\n    'Айгуль': 'Казань',\n    'Алёна': 'Белгород',\n    'Даниил': 'Санкт-Петербург',\n    'Лев': 'Тула',\n    'Валера': 'Сыктывкар',\n    'Антон': 'Ялта',\n    'Карен': 'Краснодар'\n}\n# Здесь ваш код\n////////////////////////////////",
      "isLock": true
    },
    {
      "id": 29,
      "language": "Python",
      "title": "Урок 29. Операции с коллекциями.",
      "text": "Списки, словари и множества в Python называются коллекциями.\nПроверить, есть ли в коллекции определённый элемент, можно условной конструкцией if с оператором in.\nСоздадим в коде несколько коллекций и поищем в них значение \"дрыхнуть\":\n\n# Список (list): в квадратных скобках:\nsleep_list = [\n    'спать', \n    'дрыхнуть', \n    'кемарить',\n    'спать'\n] \n# Множество (set): в фигурных скобках, элементы выглядят как в списке,\n# но не могут повторяться:\nsleep_set = {\n    'дрыхнуть', \n    'спать', \n    'кемарить'\n} \n# Словарь (dict): в фигурных скобках, элементы выглядят как ключ:значение;\n# ключи не могут повторяться:\nsleep_dict = {\n    'спать': 'дрыхнуть', \n    'почивать': 'кемарить'\n}\n# Есть ли элемент 'дрыхнуть' в списке sleep_list?\nif 'дрыхнуть' in sleep_list:\n    print('В списке: нашлось!') \nelse:\n    print('В списке: не нашлось :(')\n# Есть ли элемент 'дрыхнуть' в сете sleep_set?\nif 'дрыхнуть' in sleep_set:\n    print('В сете: нашлось!') \nelse:\n    print('В сете: не нашлось :(')\n# Есть ли элемент 'дрыхнуть' в словаре sleep_dict?\nif 'дрыхнуть' in sleep_dict:\n    print('В словаре: нашлось!') \nelse:\n    print('В словаре: не нашлось :(')\n\nВ списке и сете нужное слово обнаружилось, а вот в словаре — нет. Дело в том, что в работе с оператором in у словарей есть особенность:\nэтот оператор проводит поиск только по ключам, а в словаре sleep_dict слово «дрыхнуть» — это значение элемента, поэтому элемент и не был найден.\nЕсли нужно убедиться, что определённого элемента нет в коллекции — поможет логический оператор not:\n\n# Список животных в лесу Белого Рыцаря\nforest_list = ['лось', 'коза', 'барсук', 'глухарь', 'лиса', 'ёж']\nif 'слонёнок' not in forest_list:\n    print('но нету слонёнка в лесу у меня,')\n    print('слонёнка весёлого нет!')\n\nПрограммисты (из числа любителей наблюдать за жирафами) написали программу, которая решает, стоит ли им идти в зоопарк или нет.\nС помощью комбинирования ветвления с операторами not и in программа проверяет, есть ли жираф в списке всех животных зоопарка.\nИ если да, то сообщает, что нужно бежать и смотреть на него; а если нет — лучше остаться дома. Запустите программу и узнайте планы программистов на сегодня.\n\nzoo_animals = ['лось', 'слон', 'морж', 'жираф', 'лиса', 'кенгуру', 'панда']\nif 'жираф' not in zoo_animals:\n    print('Остаемся дома и смотрим на жирафов в интернете')\nelse:\n    print('Вот это удача! Скорее бежим в зоопарк!')\n\nСегодня им повезло! Как и жирафу, которому достанется много внимания.\n\nДобавление элементов в коллекции\nВ список можно добавить новый элемент методом append(). Новый элемент будет добавлен в конец списка:\n\nsleep_list = [\n    'спать', \n    'дрыхнуть', \n    'кемарить', \n    'спать'\n] \n# Метод append() добавит строку 'посапывать' в конец списка\nsleep_list.append('посапывать')\nprint(sleep_list)\n\n# Будет напечатано:\n# ['спать', 'дрыхнуть', 'кемарить', 'спать', 'посапывать']\n\nДобавить новый элемент в множество можно методом add(), он работает аналогично методу append() для списков.\nОтличие лишь в том, что новый элемент будет добавлен не в конец множества. Ведь множество не упорядочено, и у него нет начала и конца.\n\nЗадача 1\nДобавьте в множество playlist несколько новых композиций (они собраны в списке new_music).\nВызывать вручную метод add() для каждой новой записи будет нерационально, пусть за вас потрудится цикл for...in.\nПлейлист станет больше и веселее!\n\nplaylist = {\n    'Venus',\n    'Yesterday',\n    'Fireball',\n    'Time',\n    'Poison',\n    'Thunderstruck'\n}\nnew_music = [\n    'Kashmir',\n    'Smoke on the Water',\n    'Bohemian Rhapsody',\n    'Zombie',\n    'Let It Be',\n    'Its My Life'\n]\nfor ...\n    # Здесь ваш код\nprint(playlist)\n\nЗадача 2\nПеред поездкой в командировку будет полезно покопаться в записной книжке и выяснить — а кто из друзей живёт в том городе, куда предстоит поехать.\nКто покажет город лучше, чем местный житель?\nНаучите программу анализировать список друзей и определять, живёт ли кто-нибудь из друзей в пункте назначения.\nДля этого напишите функцию is_anyone_in(collection, city).\nДля каждого неподходящего города функция должна напечатать фразу:\nВ городе <название_города> у меня есть друг, но мне туда не надо.\nЕсли кто-то из друзей живёт в запрошенном городе — функция должна напечатать фразу\nВ городе <название_города> живёт <имя_друга>. Обязательно зайду в гости!\n\nfriends = {\n    'Серёга': 'Омск',\n    'Соня': 'Москва',\n    'Дима': 'Челябинск',\n    'Алина': 'Хабаровск',\n    'Егор': 'Пермь'\n}\ndef is_anyone_in(collection, city):\n    for friend in ...\n        if ...\n            print(...)\n        else:\n            print(...)\nis_anyone_in(friends, 'Хабаровск')",
      "isLock": true
    },
  {
    "id": 31,
    "language":"Java",
    "title": "Урок 1. Знакомство с Java.",
    "text": "По сложившейся традиции каждый программист начинает свой путь с вывода на экран фразы «Привет, мир!» (англ. Hello, world!).\nНе будем нарушать этот обычай — поприветствуем мир на языке Java. Но для начала немного теории для понимания.\nЕсли открыть любой онлайн компилятор или среду разработки (приложение для написание кода), то Вас встретит данная конструкция:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\npublic class Main\n{\n\tpublic static void main(String[] args) {\n\t\t//какой-то код\n\t}\n}\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nНе пугайтесь ее! На месте \"//какой-то код\" вам и нужно будет вставлять блоки кода, которые даются в теории или в заданиях.\nА чтобы вам было более понятно, что это за конструкция:\nстрокой \"public class Main\" мы показываем, что этот \"кусочек программы\" главный и из него будет стартовать наше приложение.\nА строкой \"public static void main(String[] args)\" мы показываем, что этот кусочек \"кусочка программы\" запуститься самым первым!\nВозможно звучит сложно, но не бойтесь, Вы обязательно освоитесь! Далее в курсе мы расскажем об этом более подробно.\n\nТеперь можно приступить к строке \"Привет мир!\". Если вы зайдете в любой онлайн компилятор, то с вероятностью 99.9%, там уже будет написана строка, которая выведет строчку \"Hello world!\". Однако, если это не так, то просто вставьте эту строчку, как было описано выше:\n\n//////////////////////////////////\nSystem.out.println(\"Hello World\");\n//////////////////////////////////\n\nУра! Первый шаг в программирование сделан! Разберём, что у нас получилось. Код состоит из одной команды, или метода, — System.out.print().\nSystem.out указывает, что нужно вывести данные на экран, print (англ. «печатать») печатает содержимое круглых скобок.\nПарные кавычки-лапки \"\" — знак того, что выводится текстовая строка (англ. string). Строка может содержать любой текст — не только \"Привет, мир!\", как в нашем примере.\nТочка с запятой в конце означает, что команда завершена.\nВажно понимать, что компьютер умеет общаться с пользователем только через ввод (англ. in) и вывод (англ. out).\nПользователь вводит данные через клавиатуру, а программа выводит их на экран. Команда System.out как раз показывает, что программа выведет данные на экран.\nКак у любого другого языка, у Java есть свои правила синтаксиса. Если их не соблюдать, код не будет работать.\nПостепенно вы узнаете и выучите и другие правила написания кода на Java. Главное — не бояться делать ошибки. Даже опытные программисты нередко ошибаются.\nНо чем больше вы будете знать, тем быстрее сможете найти проблему в коде и исправить её. Уже сейчас вы проверите свои знания. Вперёд к практике!\nВместо многоточия напишите ваше имя, чтобы код его напечатал. Например: \"Достоевский Фёдор Михайлович\".\n\nМетод println()\nУ метода print() есть особенность — он печатает всё на одной строке. Чтобы убедиться в этом, запустите следующий код в онлайн компиляторе:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nSystem.out.print(\"Это напечатано на одной строке.\");\nSystem.out.print(\"А это на другой!\");\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nСейчас две фразы будто бы слились воедино. Чтобы строки были одна под другой, нужен метод println(). Окончание -ln — это сокращение от line (англ. «линия»).\nprintln() сначала печатает значение в скобках, а потом переходит на следующую строчку. Изменим пример выше, чтобы текст был напечатан в две строки.\nЗапустите код в онлайн компиляторе:\n\n//////////////////////////////////////////////////////\nSystem.out.println(\"Это напечатано на одной строке.\");\nSystem.out.println(\"А это на другой!\");\n//////////////////////////////////////////////////////\n\nТеперь каждая строка на своём месте! Переход на следующую строку позволяет сразу визуально различить два разных вывода.\nПоэтому в программировании практически всегда используется println. Этой командой будете пользоваться и вы! :)\n\nЗадание 1\nВыведите на экран следующий текст на разных строках.\n\n\"Теперь я умею выводить строки на экран\"\n\"Скоро я стану разработчиком\"",
    "isLock": false
  },
  {
    "id": 32,
    "language": "Java",
    "title": "Урок 2. Переменные.",
    "text": "В предыдущем уроке вы научились печатать текст и переносить его на новую строчку.\nТеперь перейдём к понятиям, без которых невозможно написать программу. Первое, что рассмотрим, — переменные.\n\nДля чего нужны переменные\nПредставьте, что вы не можете запомнить, где остановились, читая книгу.\nНомер страницы вылетает из головы, поэтому каждый раз приходится перелистывать томик с самого начала: 10, 27, 140, 250 страниц.\nТо же самое происходит с программами, которые не могут сохранять данные. Именно поэтому программирование начинается с переменных.\nС их помощью в программе хранятся данные.\nПеременная работает как подписанная коробка или помеченная ячейка, куда можно что-то положить, чтобы не потерять.\nУ переменной есть имя — с его помощью вы всегда сможете к ней обратиться, а также значение — данные, которые нужно сохранить.\nНапример, у вас дома есть банка, в которой хранится 300 граммов сахара. Для удобства она подписана:\nтак вы точно не перепутаете сахар с солью, когда захотите подсластить кофе. В коде на Java описать эту «банку» можно вот так:\n\n\\\\\\\\\\\\\\\\\nint sugar = 300;\n\\\\\\\\\\\\\\\\\\\n\nВ результате будет создана переменная с именем sugar (англ. «сахар») и значением 300.\nJava не знает, что переменная sugar будет хранить число, ей нужно сообщить об этом, указав перед именем переменной её тип.\nПосле имени переменной идёт знак =. Он даёт понять, что переменная должна хранить значение, указанное после знака.\nЭта операция называется присваиванием, а знак = — оператором присваивания.\nТип определяет, какие именно значения может хранить переменная. Мы используем int — целочисленный тип данных.\nК нему относятся числа без дробной части, такие как 1, 0, 3, -10 или 300.\nДля чисел с дробной частью — например, 3.1 или -4.7 — используется тип double. Так, хорошо известное со школы число Пи на языке Java можно описать так:\n\n\\\\\\\\\\\\\\\\\\\ndouble pi = 3.14;\n\\\\\\\\\\\\\\\\\\\n\nОбратите внимание, что вместо запятой Java использует точку для отделения целой части от дробной.\nПросто хранить значения бесполезно, ими нужно уметь пользоваться — для этого к переменной можно обратиться по имени.\nЧтобы вывести значение переменной на экран, нужно просто написать имя переменной без кавычек в круглых скобках метода System.out.println(). Например:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ndouble pi = 3.14;\nSystem.out.println(pi);\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nКак написать имя переменной\nПосле типа переменной пишется её имя. Его придумывает сам программист.\nИмя переменной может состоять из букв латинского алфавита и цифр, например: rub, variable1 или rate123.\nСуществует негласное правило — давать переменным осмысленные имена на английском языке. Например, flatNumber вместо nomerKvartiry или someVariable.\nМожно даже дать переменной имя, состоящее из нескольких слов. Важное правило: эти слова должны быть написаны слитно, иначе произойдёт ошибка.\nА ещё каждое слово, кроме первого, принято писать с заглавной (большой) буквы.\nТакой стиль написания имён называется lowerCamelCase (англ. «нижнийВерблюжийРегистр»).\nПервая буква обязательно «маленькая», строчная, по-английски — lowercase letter, а прописные внутри слова напоминают горбы верблюда.\nСтарайтесь подбирать логичные имена для переменных, чтобы было сразу понятно, для чего именно они используются.\nТак вам и другим программистам будет проще читать и понимать код. В больших проектах могут быть сотни переменных!\nКроме того, разработчики обычно пишут коллективно, вам придётся иметь дело с чужим кодом, и было бы здорово, если бы вы без проблем смогли читать и понимать его.\n\nОбъявляем переменную\nМожно создать переменную, но не записывать в неё никакого значения. Это называется объявлением переменной:\n\n\\\\\\\\\\\\\\\\\\\\\\\\n\ndouble brownSugar;\n\n\\\\\\\\\\\\\\\\\\\\\\\\\n\nПока она не связана ни с каким значением. Обычно так делают, если значение переменной не известно сразу, а вычисляется в процессе работы программы.\nВозвращаясь к нашей аналогии, представим, что переменная без значения — это пустая баночка. На этой баночке написано имя, но в неё ещё ничего не положили.\nКак только у вас появится нужная вещь, вы сразу же сохраните её там.\nЧтобы в переменной сохранилось значение, его нужно присвоить:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ndouble brownSugar;\nbrownSugar = 150.5;\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nЗдесь в строке double brownSugar; мы объявили переменную, а в строке brownSugar = 150.5; присвоили ей значение 150.5.\nТеперь в переменной brownSugar хранится значение 150.5.\nПовторно указывать тип переменной не требуется: Java запомнила его при объявлении.\nЕсли вы сразу знаете значение, которое хотите присвоить, то лучше заменить две строки кода одной.\nНапример, объявим переменную brownSugar и сразу же присвоим ей значение 82.2:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\ndouble brownSugar = 82.2;\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nТеперь переменная готова к использованию. Вывести на экран её значение можно с помощью уже знакомой вам команды System.out.println.\nНапомним, при выводе переменной кавычки не ставятся:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\ndouble brownSugar = 82.2;\nSystem.out.println(brownSugar);\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nВ результате будет напечатано число 82.2. Таким образом, если вы хотите использовать значение переменной,\nто нужно просто написать её имя, и вместо него автоматически будет подставлено значение.\n\nЗадача 1.\nОбъявите переменную cornFlakes для хранения количества кукурузных хлопьев в граммах. Отдельным шагом присвойте ей значение 78.7. В конце напечатайте значение cornFlakes.",
    "isLock": true
  },
  {
    "id": 33,
    "language": "Java",
    "title": "Урок 3. Работа с переменными.",
    "text": "Вы уже познакомились с переменными и знаете, как давать им имена и как их объявлять. Но это не единственное, что можно с ними делать.\nСейчас расскажем, как ещё с ними можно работать.\n\nМеняем значение переменной\nСамо название «переменная» говорит, что её значение можно менять. Посмотрим, как это сделать:\n\nint age = 30;\nage = 31;\n\nСначала в переменной age сохранили значение 30, а потом, когда, например, наступил день рождения, изменили его на 31.\nМожно сколько угодно раз присваивать переменной новое значение. Главное, чтобы его тип совпадал с типом, который вы использовали при объявлении.\nНапример, нельзя переменной с типом int присвоить дробное число. При попытке выполнить следующий код получим ошибку:\n\nint age = 30;\nage = 44.4;\nSystem.out.println(age);\n\nЕщё вы можете присвоить одной переменной значение другой. Например, при получении данных можно их обновить у себя в программе:\n\nint priceForCucumber = 7;\n...\nИз другой системы получили данные о новой цене в переменной newPrice,\nв newPrice сохранено значение 10.\n...\nint priceForCucumber = newPrice;\n\nТеперь в priceForCucumber сохранено значение 10.\nЗдесь в переменную priceForCucumber сохранили значение переменной newPrice.\n\nПеременные и арифметические операции\nОдна из задач, которую решает программирование, — преобразование данных. Оно нужно, чтобы, например, зная количество товара и цену, вычислить стоимость покупки.\nИли по размерам посылок рассчитать, какой транспорт потребуется для их доставки.\nС переменными типа int и double — числами — можно выполнять любые арифметические операции: складывать (с помощью знака +), вычитать (-), умножать (*) и делить (/).\nСкопируйте код и запустите его в онлайн-компиляторе, чтобы посмотреть результат.\n\nint a = 3;\nint b = 5;\nint result = a + b;\nSystem.out.println(result);\n\nПри выполнении сложения вместо имён переменных подставляются их значения — 3 и 5. В результате будет напечатано число 8.\nВ выражениях можно смешивать переменные и числа:\n\nint minutesPerHour = 60;\nint minutesPerDay = minutesPerHour * 24;\nSystem.out.println(minutesPerDay);\n\nпри делении на ноль всегда возникает ошибка.\n\nint wrongOperation = 10 / 0;\n\nException in thread \"main\" java.lang.ArithmeticException: / by zero\nat Main.main(Main.java:12)\n\nПолучим сообщение об ошибке: / by zero — «деление на ноль».\n\nУ операций умножения и деления более высокий приоритет, чем у сложения и вычитания. Та операция, приоритет которой выше, выполнится первой:\n\nint x = 3;\nint y = 5;\nint result = 10 + x * y;\nSystem.out.println(result);\n\nВ переменной result будет сохранено значение 25. Сначала выполнилось умножение x * y = 15 и только после этого сложение 10 + 15.\nПриоритет можно задавать с помощью скобок: выражение в скобках выполнится в первую очередь.\nНапример, если в предыдущем примере расставить скобки, то результат будет совсем другим:\n\nint x = 3;\nint y = 5;\nint result = (10 + x) * y;\nSystem.out.println(result);\n\nВ переменной result будет сохранено значение 65. Сначала выполнится то, что в скобках, — 10 + x = 13, а после — умножение 13 * 5 = 65.\nКстати, если вы хотите напечатать результат какого-то выражения, необязательно сохранять его в переменную.\nВы можете просто написать выражение внутри команды println():\n\nint x = 3;\nint y = 5;\nSystem.out.println((10 + x) * y);\n\nВ этом случае также будет выведен результат 65.\n\ndouble x = 7.5;\ndouble y = 4.5;\ny = y - 2;\nx = y;\ndouble result = (y - 0.5) * 2 + 3.5 + x * 2;\n\n(В x и y хранится значение 2.5. Затем происходит вычисление значения переменной result по формуле (2.5 - 0.5) * 2 + 3.5 + 2.5 * 2 — если подставить вместо x и у 2.5,\nполучим значение 12.5.)\n\nЗадача 1.\nУзнав, что вы занялись программированием, ваш друг попросил написать несложный калькулятор для конвертации мегабайтов в гигабайты.\nВы пока умеете немного, но уже знаете достаточно, чтобы помочь ему! В переменной gigabytes сохраните количество гигабайт.\nДля этого мегабайты нужно разделить на количество мегабайт в одном гигабайте. Выведите значение переменной gigabytes на экран.\n(На месте многоточий должен быть ваш код)\n\ndouble megabytes = 32409.6;\ndouble megabytesPerGigabyte = 1024;\ndouble gigabytes = ...;\nSystem.out.println(...);",
    "isLock": true
  },
  {
    "id": 34,
    "language": "Java",
    "title": "Урок 4. Комментарии к коду и их оформление.",
    "text": "Вы уже умеете писать маленькие программы. Вам даже не нужны подсказки, чтобы понять, что будет делать программа.\nНо пока вы работали только с несколькими строками, которые написали сами.\nА теперь представьте, что вам придётся работать с большим количеством кода. Или, допустим, вы работаете над программой вместе со своим коллегой.\nКак понять, для чего нужны те или иные команды и строки?\nЧтобы было проще читать код, в нём можно писать комментарии. Благодаря им становится понятно, что происходит в программе.\nКомментарии пишутся для людей. Программа их игнорирует. Проверьте сами: если в программе написать следующую строку, то ничего не произойдёт.\n\n//////////////////////////////////////\n//System.out.println(\"Ничегошеньки!\");\n//////////////////////////////////////\n\nВсё потому, что в начале строки стоит двойной слеш — //. С него начинается комментарий. Любые символы после — игнорируются.\nПопробуйте убрать символы — раскомментировать код — и убедитесь, что программа печатает строку.\nЗапустите код в онлайн компиляторе и посмотрите на результат. А затем раскомментируйте код и запустите его снова.\n\n////////////////////////////////////////\ndouble currentSpeed = 40.00;\ndouble speedToMyFavouriteCat = 60.00;\n// currentSpeed = speedToMyFavouriteCat;\nSystem.out.println(currentSpeed);\n////////////////////////////////////////\n\nВ комментариях можно писать пояснения, объясняющие, что делает код. Писать комментарии можно на любом языке, даже на их количество нет ограничения.\nОднако злоупотреблять ими не стоит: если комментарии просто дублируют то, что и так понятно из кода, это только отвлекает.\nТакже в «промышленном» программировании код часто обновляется, а значит, придётся следить и за обновлением комментариев.\n\nЗадача 1.\nКод не работает. Исправьте ошибку — закомментируйте нужную строку.\n\n////////////////////////////////////////////////////\ndouble kilobytes = 324534272;\nВычисляем, сколько килобайт в одном гигабайте\ndouble kilobytesPerGigabyte = 1024 * 1024;\ndouble gigabytes = kilobytes / kilobytesPerGigabyte;\n\nSystem.out.println(\"Вот столько килобайт:\");\nSystem.out.println(kilobytes);\nSystem.out.println(\"Это столько гигабайт:\");\nSystem.out.println(gigabytes);\n////////////////////////////////////////////////////\n\nМногострочные комментарии\nЕсли вы хотите закомментировать сразу несколько строк в программе, то можно написать так:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n// Комментарий 1 \n// Комментарий 2\nSystem.out.println(\"Комментарии — это просто\"); \n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nПроблема возникнет, если нужно будет закомментировать (проигнорировать) не две строки, а гораздо больше. Например, сразу десять.\nСтавить перед каждой строкой // неудобно: вы потратите на это много времени. К тому же код будет казаться громоздким.\nДля решения этой проблемы в Java существуют многострочные комментарии. Они обозначаются так:\n\n/* Все\nстроки\nбудут\nпроигнорированы */\n\nТаким образом, /* открывает комментарий, а */ — закрывает. Всё, что написано между ними, Java проигнорирует.\nВажно не забывать закрывать многострочный комментарий. Если вы попробуете запустить следующую программу, то ничего не будет напечатано.",
    "isLock": true
  },
  {
    "id": 35,
    "language": "Java",
    "title": "Урок 5. Строки. Конкатенация.",
    "text": "В программировании не все задачи сводятся к работе с числами. Часто возникает необходимость обрабатывать текстовые данные.\nНапример, когда в приложении нужно собрать из разных полей в окне оформления доставки единый текст адреса, который будет передан курьеру.\nИли напечатать приветствие, используя стандартное приветствие и имя пользователя.\nДля этого в Java используются переменные, которые представляют собой строки символов. Рассмотрим их подробнее.\n\nСоздаём строки\nДля нечисловых переменных в Java есть свой тип данных. Вы уже сталкивались с ним, когда выводили текст на экран:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nSystem.out.println(\"Привет, мир!\")\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nКак и числа, строки можно хранить в переменных. Вы уже знаете, что объявление переменной начинается с указания её типа.\nДля строк он называется String (англ. «строка»). Обратите внимание, что его название пишется с заглавной буквы.\nПозже подробнее расскажем, в чём разница между типами, названия которых начинаются с маленькой буквы (int, double) и с заглавной, как у строк.\nПосле объявления переменной ей нужно присвоить значение. Напомним, что строки обязательно пишутся в двойных кавычках-лапках:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n// Переменная с именем hello и типом String\nString hello = \"Привет, мир!\";\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nТеперь, если в программе написать имя переменной, будет подставлено её значение:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nString hello = \"Привет, мир!\";\nSystem.out.println(hello); // Подставили переменную\nSystem.out.println(hello); // Подставили переменную второй раз\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nИ в результате напечатается:\nПривет, мир!\nПривет, мир!\n\nЗадача 1.\nПосле переменной hello создайте переменную name и сохраните в ней своё имя. Напечатайте её значение после приветствия.\n\n/////////////////////////////////////////////////////////////\nString hello = \"Привет!\";\n... // Объявите переменную и присвойте ей значение - ваше имя\nSystem.out.println(hello);\n... // Здесь нужно напечатать имя\n/////////////////////////////////////////////////////////////\n\nКонкатенация\nЕсли «сложить» две строки вместе, получим новую:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nString hello = \"Привет!\";\nString phrase = \"Я изучаю Java.\";\nSystem.out.println(hello + phrase);\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nБудет напечатано:\n\nПривет!Я изучаю Java.\n\nСложение строк называется конкатенацией. Смысл у этой операции такой: берётся значение первой строки, к нему «дописывается» значение второй строки.\nКак и с числовыми переменными, результат можно сохранить в новую переменную:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nString hello = \"Привет!\";\nString phrase = \"Я изучаю Java.\";\n\n// Сохраняем результат в отдельную переменную\nString helloJavaPhrase = hello + phrase;\nSystem.out.println(helloJavaPhrase);\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nРезультат не изменится:\n\nПривет!Я изучаю Java.\n\nВ строке «Привет!Я изучаю Java.» не хватает пробела между фразами. Пробел можно добавить отдельной строкой, заключив его в кавычки:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nString hello = \"Привет!\";\nString student = \"Я изучаю Java.\";\n\nSystem.out.println(hello + \" \" + student);\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nЭтот пример демонстрирует сразу две важные детали.\nВы можете, во-первых, конкатенировать сколько угодно строк, а во-вторых, смешивать строки, хранящиеся в переменных, со строками, заключёнными в кавычки.\n\nЗадача 2.\nИзмените код предыдущего задания. Пусть теперь он печатает строку вида: Привет! Меня зовут Сема. Я кот.. Обратите внимание, что предложения должны быть разделены пробелами.\n\n/////////////////////////////////////////\nString hello = \"Привет!\";\nString myNameIsSema = \"Меня зовут Сема.\";\nString iAmCat = \"Я кот.\";\n\n// Напечатайте фразу\n/////////////////////////////////////////\n\nОбъединяем строки и значения типов\nПри конкатенации необязательно использовать только строки. Можно «прибавлять» к строке значения разных типов:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nint lessonNumber = 7;\nSystem.out.println(\"Сейчас я на уроке №\" + lessonNumber + \"!\");\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nВ этом случае число автоматически преобразуется в строку, будет напечатано:\n\nСейчас я на уроке №7!\n\nМожно даже подставлять арифметические выражения:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ndouble price = 120.5; // Цена за килограмм\ndouble weight = 3.5; // Вес в килограммах\nSystem.out.println(\"Цена за \" + weight + \" килограмма = \" + price * weight);\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nЕсли сложить строку с числом, получится строка. При этом важен порядок действий. Разберём пример выше подробнее.\n1. Выполняется умножение — price * weight будет 421.75.\n2. Складываем \"Цена за \" +[значение переменной weight, равное 3.5]. Получится строка Цена за 3.5.\n3. Добавим \" килограмма = \", получим строку — Цена за 3.5 килограмма = .\n4. К строке из третьего действия добавим 421.75 и получим финальный результат: Цена за 3.5 килограмма = 421.75.\nЕсли же все значения числовые, + будет работать как обычный знак сложения.",
    "isLock": true
  },
  {
    "id": 36,
    "language": "Java",
    "title": "Урок 6. Метод main().",
    "text": "Ранее, в первом уроке, мы немного рассказали про данную конструкцию:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nclass Main {  \n    public static void main(String[] args) {\n\n        System.out.println(\"Ну, привет!\");\n    }\n} \n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nТеперь расскажем о ней более подробно. Команда System.out.println() вам уже знакома. Разберём, что находится «вокруг» неё.\n\nМетоды и классы\nВесь код в Java пишется в классах (англ. class). Класс — это способ организации кода. Если представить, что программа на Java — это мебельная фабрика,\nто классы в ней будут цехами. Каждый из этих цехов отвечает за разные процессы и производит различные детали.\nВ Java с помощью классов код приложения разделяется на логические блоки.\nПока у нас только один-единственный класс с именем Main. Объявим его в первой строке программы:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nclass Main {  // Сказали Java, что это класс Main\n}\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nОбъявить класс — значит написать слово class, его название (в нашем случае это Main) и фигурные скобки, которые показывают конец и начало класса.\nВнутри класса — описание метода с именем main(). Метод — это набор сгруппированных команд, которому присвоено имя. По имени метод можно вызывать:\nкак мы вызываем метод System.out.println() для печати сообщений на экран, так и Java вызывает метод main(), чтобы начать выполнять программу.\nБез метода main() Java не будет знать, где начало программы. Особенно если в программе много разных методов.\n\nКак мы рассказывали ранее, println() — тоже метод. Он описан отдельно. Внутри него скрыто два действия: вывести текст на экран и после этого перейти на новую строку.\nПосле имени метода всегда ставятся круглые скобки — они дают нам понять, что это именно метод, а не переменная.\n\nМетод main()\nВ Java метод main() (англ. «главный», «основной») — это входная точка любой программы.\nКак только вы запускаете программу, выполняется код, написанный внутри этого метода.\nСам метод описывается так: public static void main(String[] args). После него в фигурных скобках пишем код программы.",
    "isLock": true
  },
  {
    "id": 37,
    "language": "Java",
    "title": "Правила синтаксиса Java.",
    "text": "Мы уже рассказали про некоторые правила синтаксиса Java. Пришло время закрепить их!\nЕщё в этом уроке вы узнаете, как правильно оформлять код, и научитесь искать и исправлять ошибки. Поехали!\n\nКоманда завершается точкой с запятой\nЭто важное правило синтаксиса Java вы изучили первым. Каждая команда должна завершаться точкой с запятой, даже если она находится на последней строчке.\n\nЗадача 1.\nРасставьте точки с запятой так, чтобы код работал правильно.\n\n/////////////////////////////////////\nString; firstRule\nfirstRule = \"Важно не забывать про ;\"\nSystem.out.println(firstRule)\nSystem.out.println(\"; – это важно\")\n/////////////////////////////////////\n\nНазвание имеет значение\nИмя переменной может состоять из букв латинского алфавита и цифр. Если переменная состоит из нескольких слов, то они должны быть написаны слитно.\nИмя такой переменной принято писать в стиле lowerCamelCase. А ещё здорово, если имена будут осмысленными.\n\nКомментарии игнорируются\nКомментарии позволяют вставлять текст, который будет проигнорирован программой, и используются для объяснения кода.\nКомментарий начинается с двойного слеша // и заканчивается в конце строки.\nТакже можно использовать многострочные комментарии, которые начинаются с /* и заканчиваются */.\n\nЗадача 2.\nЗакомментируйте часть кода так, чтобы вывести на экран 10. Обратите внимание, что ничего другого в этом коде не нужно менять. Только комментарии.\n\n/////////////////////////////////\nint x = 5;\nint y = 7;\nx = x + 1;\ny = 15 - x;\nx = x * y; \nint result = y - x;\nresult = x * 2;\nSystem.out.println(result + \"0\");\n/////////////////////////////////\n\nСтавим фигурные скобки\nПосле объявления класса и метода ставятся фигурные скобки. Фигурные скобки группируют код.\nОткрывающую скобку класса или метода принято ставить на той же строке, а закрывающую — на отдельной, причём с таким же количеством отступов,\nсколько было у класса или метода. Это не строгое правило, а договорённость среди программистов, которая позволяет делать код более простым для чтения и восприятия.\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nclass Main {\n    // Внутри класса, снаружи метода\n    public static void main(String[] args) {\n        // Внутри метода\n    }\n}\n// Снаружи класса\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nПоиск и исправление ошибок\nНарушение правил синтаксиса приводит к ошибкам. Но не переживайте, Java подскажет, где именно возникла проблема.\nДопустим, вы написали программу и забыли поставить точку с запятой. Если вы попытаетесь запустить её, возникнет ошибка:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nclass Main {\n    public static void main(String[] args) {\n        System.out.println(\"Ошибки случаются! Это не страшно:)\") // Не поставили точку с запятой\n    }\n}\nРазберём подробнее, что означает эта ошибка:\n...\\Main.java:3:65\njava: ';' expected \n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nПервая строка сообщения об ошибке указывает, в каком именно классе та произошла. Это класс с именем Main.java.\nПосле перечислены номер строки и позиция, где произошла ошибка: на третьей строке в 65-й позиции (каждый символ в строке — это одна позиция).\nА в чём именно состоит проблема, сообщает вторая строка: Java ожидает точку с запятой.\n\nПодытожим:\n• ...\\Main.java: — имя класса, в котором произошла ошибка.\n• 3:65 — номер строки и символа с ошибкой.\n• java ';' expected — суть ошибки: в примере пропущена точка с запятой.\n\nЭти знания помогут вам сориентироваться, в чём ошибка, и быстрее её исправить. Помните, что ошибки в коде — это абсолютно нормально.\nВсе их допускают. Главное — научиться находить их и исправлять.",
    "isLock": true
  },
  {
    "id": 38,
    "language": "Java",
    "title": "Пишем первое приложение.",
    "text": "Вы узнали, как работать с переменными, числами и строками. Осталось только структурировать эту информацию и написать первую программу.\nДля этого нужно писать весь код внутри метода main().\n\nЗадание\nНапишите конвертер валют, который умеет работать с рублями и долларами:\n• Установите стартовое значение на счету: 30002.7 рубля. Используйте переменную rubles.\n• Курс доллара установите равным 78.5 рублям за доллар. Используйте переменную rateUSD.\n• Вычислите значение в долларах: для этого переменную с количеством рублей необходимо поделить на курс доллара. Результат сохраните в переменную dollars.\n• В результате работы программы напечатайте следующую строку: У вас на счету ... рублей. В долларах это ... долларов. Так держать!.\nВместо многоточий подставьте соответствующие значения переменных. Скопируйте код в онлайн компилятор и попробуйте выполнить задание.\n\n///////////////////////////////////////////////////////////////////\nclass Main {\n\n    public static void main(String[] args) { \n        // Объявите переменные и произведите необходимые вычисления\n        ...\n        System.out.println(...);\n    }\n}\n///////////////////////////////////////////////////////////////////",
    "isLock": true
  },
  {
    "id": 39,
    "language": "Java",
    "title": "Тип boolean и операторы сравнения.",
    "text": "В прошлой теме вы познакомились с синтаксисом Java и узнали самые азы этого языка. Теперь перейдём к ещё одному основному понятию — к условиям.\nУсловия играют важную роль в программировании. Благодаря им программа принимает логическое решение, в зависимости от которого выполняет те или иные действия.\nУсловия есть буквально в каждой программе: в играх в зависимости от них будет развиваться сюжет, в банковских приложениях будут меняться тарифы и начисляться кешбэк,\nа в онлайн-кинотеатре — проверяться доступность фильмов.\nВ этой теме вы узнаете, что такое условные операторы и как с ними работать. Начнём погружение с логического типа данных — boolean.\nРазберём, для чего он нужен и как его применять на практике.\n\nЛогические выражения\nТип boolean (от англ. «булевый», «логический») позволяет работать с выражениями, которые могут быть истинными или ложными.\nЭтот логический тип данных, например, позволит пользователю влиять на развитие сюжета в компьютерной игре.\nУ boolean всего два значения — true (англ. «истина») и false (англ. «ложь»). Их можно сравнить со словами «да» и «нет».\nЕсли на какой-то вопрос можно ответить «да», то это true, если «нет» — false. Например, значение типа boolean появляется при сравнении чисел:\n\n5 > 3 – истина, значение true\n\nОбъявляется переменная типа boolean, как и другие типы переменных: сначала нужно указать тип переменной, затем — её название.\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nclass Main {\n    public static void main(String[] args) {\n        boolean result = 5 > 3;\n        System.out.println(result); // напечатает true\n    }\n}\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nОператоры сравнения\nУ операторов сравнения Java математический смысл. Они нужны, чтобы сопоставить две величины между собой.\nС их помощью можно сравнивать как числа, так и переменные. Перечислим стандартные операторы:\n\n• > — оператор «больше». Возвращает true, если элемент слева больше элемента справа, и false в противоположном случае.\n  3 > 5 // Три больше пяти? Нет, это ложь -> false\n  7 > 7 // Семь больше семи? Нет, это ложь -> false\n  5 > 2 // Пять больше двух? Да, это так -> true\n\n• < — оператор «меньше». Возвращает true, если элемент слева меньше элемента справа. В остальных случаях возвращает false.\n  3 < 5 // Три меньше пяти? Да, это так -> true\n  7 < 7 // Семь меньше семи? Нет, это ложь -> false\n  5 < 2 // Пять меньше двух? Нет, это ложь -> false\n\n• >= — оператор «больше или равно». Возвращает true, если элемент слева больше или равен элементу справа. Иначе — false.\n  3 >= 5 // Три больше или равно пяти? Нет, это ложь -> false\n  7 >= 7 // Семь больше или равно семи? Да, это так -> true\n  5 >= 2 // Пять больше или равно двум? Да, это так -> true\n\n• <= — оператор «меньше или равно». Возвращает true, если элемент слева меньше или равен элементу справа. В противном случае возвращает false.\n  3 <= 5 // Три меньше или равно пяти? Да, это так -> true\n  7 <= 7 // Семь меньше или равно семи? Да, это так -> true\n  5 <= 2 // Пять меньше или равно двум? Нет, это ложь -> false\n\nОператоры >= и <= нужно вводить именно двумя символами — «меньше» и «равно» или «больше» и «равно». Java не понимает единые символы: «≤» и «≥».\nА вот ещё несколько примеров, в том числе с переменными:\n\n3 < 5 // Три меньше пяти? Да, это так -> true\n4 > 8 // Четыре больше восьми? Нет, это ложь -> false\n\nint three = 3;\nint six = 6;\nthree >= 5; // Три больше или равно пяти? Нет -> false\nsix <= 8; // Шесть меньше или равно восьми? Да -> true\n\ndouble sevenAndAHalf = 7.5 // Объявим переменную, равную 7.5\n5.5 > sevenAndAHalf; // 5.5 больше 7.5? Нет -> false\n\nВсе эти операторы сравнения пригодятся, когда в коде нужно будет записать условия. Как это сделать, мы обязательно расскажем чуть позже. А пока — проверьте себя!\n\nБулевы переменные\nКак мы рассказали выше, результат сравнения можно присвоить переменной и использовать её в дальнейшем.\nЗапустите этот код в онлайн компиляторе и посмотрите, что будет напечатано:\n\n/////////////////////////////////////////////////////////////////////\nclass Main {\n    public static void main(String[] args) {\n        boolean isMore = 3 > 4;\n        System.out.println(\"Значение переменной isMore = \" + isMore);\n    }\n}\n/////////////////////////////////////////////////////////////////////\n\nВ результате значение переменной isMore будет равно false. Кстати, мы не случайно назвали переменную именно так — isMore (англ. «больше»).\nДело в том, что название булевых переменных — типа boolean — принято начинать с префикса is (англ. «является»).\nНапример, переменные с именами isEven (англ. «чётное») и isOdd (англ. «нечётное») принято использовать для проверки чётности.\nisNegative (англ. «отрицательное») проверяет, что число отрицательное, а isPositive (англ. «положительное») — что положительное.\nЭто не жёсткое правило, но по традиции переменные называют именно так, чтобы проще было читать и понимать код.\n\nЗадача 1.\nДопишите код так, чтобы в переменной isNegative сохранялся ответ: «Является ли переменная x отрицательной». Для этого необходимо:\n• Объявить булеву переменную isNegative.\n• Сохранить в неё результат сравнения x с нулём.\n• Использовать значение переменной в выводе на экран.\n\n//////////////////////////////////////////////////////////////////////\nclass Main {\n    public static void main(String[] args) {\n        int x = -5;\n        \n        // Объявите переменную и сохраните в неё результат сравнения\n        ...\n        // Выведите значение переменной на экран\n        System.out.println(\"Значение переменной isNegative = \" + ...);\n    }\n}\n//////////////////////////////////////////////////////////////////////",
    "isLock": true
  },
  {
    "id": 40,
    "language": "Java",
    "title": "Урок 10. Проверка на равенство.",
    "text": "В прошлом уроке мы рассказали, как сравнивать элементы, которые больше или меньше друг друга. В этом уроке вы узнаете, как проверять элементы на равенство.\n\nОператоры == и !=\nОператор == нужен, чтобы проверить, равны ли элементы друг другу. Он представляет собой напечатанные подряд два символа «равно». Оператор возвращает логический результат — значение false или true:\n\n3 == 4 // Три равно четырём? Нет -> false\n\nТакое выражение тоже можно сохранить в переменной:\n\nboolean isEqual = 3 == 4;\n\nОбратите внимание, что одиночный знак = выполняет присваивание, а двойной == — проверку на равенство.\n\nМожно проверить числа и на неравенство. Для этого в Java есть оператор !=, который возвращает true, если значения не равны, и false в противоположном случае:\n\nboolean isNotEqual = 3 != 4; // Три не равно четырём? Да -> true\n\nОператоров сравнения в Java немного, но кажется, что запомнить их все сразу очень сложно. Не стоит унывать раньше времени: постоянная практика поможет решить эту проблему. Ниже предоставлена табличка операторов:\n\nОператор | Значение\n==  | равно\n!=  | не равно\n>   | больше\n<   | меньше\n>=  | больше или равно\n<=  | меньше или равно\n\nПопробуйте самостоятельно попрактиковаться, заменяя операторы сравнения и значения переменных:\n\nclass Main {\n    public static void main(String[] args) {\n        int firstNumber = 10;\n        int secondNumber = 5;\n        System.out.println(\"Результат проверки «firstNumber» равен «secondNumber»:\");\n        System.out.println(firstNumber == secondNumber);\n    }\n}\n\nА теперь – к задаче!\nВ небольшом тесте по математике было три вопроса. Напишите короткую программу, которая выводит на экран результат проверки студента. Ответы студента сохранены в переменных answer1, answer2 и answer3. В первом вопросе правильный ответ — «2». Во втором — любой, кроме «4». В третьем — «1». Сравните каждый из ответов студента с правильным, выводя true или false. Например, если на первый вопрос был дан правильный ответ, нужно вывести:\nРезультат проверки вопроса 1:\ntrue\n\nclass Practicum {\n    public static void main(String[] args) {\n        int answer1 = 3; // Ответ на 1 вопрос\n        int answer2 = 4; // Ответ на 2 вопрос\n        int answer3 = 1; // Ответ на 3 вопрос\n        System.out.println(\"Результат проверки вопроса 1:\");\n        // Выведите true или false, сравнив ответ на 1 вопрос с правильным\n        // Повторите для вопросов 2 и 3\n    }\n}\n\nМетод equals()\nПока мы рассмотрели только те случаи, где сравнивались числа — как сами по себе, так и хранящиеся в переменных. Но если нам нужно сравнить между собой строки, оператор == не всегда будет работать корректно. Пока стоит запомнить правило: для сравнения строк вместо == нужно использовать метод equals() (англ. «сравнивать», «равно»). Его синтаксис выглядит так:\n\nboolean isEqual = \"Привет\".equals(\"Здравствуйте\"); // Строки равны? Нет -> false\n\nСравним строки line1 и line2. Для этого нужно написать: line1.equals(line2). Метод equals() сравнивает строку до точки с той, что написана в круглых скобках. Если они равны, то будет возвращено true, иначе — false. Строки можно указывать в кавычках или сравнивать между собой переменные с типом String:\n\nclass Practicum {\n    public static void main(String[] args) {\n        String line1 = \"Какой-то текст\";\n        String line2 = \"Какой-то \" + \"текст\";\n        boolean isSameString = line1.equals(line2); // Переменная isSameString = true\n        System.out.println(isSameString);\n        isSameString = line1.equals(\"Другая строка\"); // Теперь переменная isSameString = false\n        System.out.println(isSameString);\n    }\n}",
    "isLock": true
  },
  {
    "id": 41,
    "language": "Java",
    "title": "Урок 11. Больше ветвлений: if — else if.",
    "text": "Вы научились писать код с условиями с помощью конструкции if-else. Теперь ваша программа может выполнить один фрагмент кода, если условие выполняется, и другой — если нет.\nНо ведь в жизни обычно вариантов выбора не два, а больше. В примере с рынком условие было таким: если яблоки красные, то покупаем их, иначе покупаем апельсины.\nПредположим, что для апельсинов тоже существует условие. Например, чтобы они обязательно были из Марокко.\nТогда алгоритм ваших действий будет таким: если есть красные яблоки, то купить их, иначе, если апельсины из Марокко, то покупаем их, иначе просто идём домой.\n\nВ коде эту логику тоже можно реализовать:\n\nif (условие 1) {\n    код #1\n} else if (условие 2) {\n    код #2\n} else {\n    код #3 \n}\nкод #4\n\nif (яблоки красные) {\n    купить яблоки;\n} else if (апельсины из Марокко) {\n    купить апельсины;\n} else {\n    тяжело вздохнуть;\n}\nпойти домой;\n\nQuiz\n• Если условие 1 истинно, тогда выполнится только код #1.\n• Когда условие 1 ложно и условие 2 истинно, то сработает только код #2.\n• Если оба условия ложны, сработает только код #3.\n\nДопустим, вы пришли на рынок. Яблоки остались только зелёные, а апельсины — исключительно испанские. Что вы сделаете?\n\nif (яблоки красные) {\n    купить яблоки;\n} else if (апельсины из Марокко) {\n    купить апельсины;\n} else {\n    тяжело вздохнуть;\n}\nпойти домой;\n\n1) Пойду домой.\n2) Куплю яблоки и пойду домой.\n3) Наберу яблок, апельсинов и отправлюсь домой.\n4) Тяжело вздохну и пойду домой.",
    "isLock": true
  },
  {
    "id": 42,
    "language": "Java",
    "title": "Урок 12. Импорт пакетов.",
    "text": "Знакомая вам команда System.out.println() выводит сообщения в окошко с названием «Вывод».\nПрограмма может также считывать оттуда данные, введённые пользователем. Сделать это можно с помощью специального типа Scanner.\n\nimport java.util.Scanner; // Импортировали пакет\n\npublic class Praktikum{\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in); // Объявили переменную с типом Scanner\n        String command = scanner.nextLine(); // Считали строку из консоли\n        System.out.println(\"Вы ввели команду \" + command);\n    }\n}\n\nВ методе main сначала создаётся переменная с типом Scanner (англ. «считывать») и именем scanner.\nТип пишется с заглавной буквы, а имя переменной — со строчной. После объявления ей присваивается значение (new Scanner(System.in)).\nДо этого мы рассматривали только простые типы — int, double, boolean. Они называются примитивными.\nА есть «сложные» типы, значения которых — это некий объект, умеющий выполнять разные действия. Для создания объектов всегда используется слово new (англ. «новый»).\nПеременная типа Scanner умеет считывать значения из потока ввода — System.in. Это указывается при её создании.\nНа следующей строке у переменной с именем scanner вызывается метод nextLine() (англ. «следующий»). Для этого после имени переменной ставится точка, и после неё — имя метода. nextLine() считывает из терминала строку и сохраняет её в переменную с именем command.\nУ типа Scanner есть ещё много разных команд. Например, nextInt() для считывания целого числа и nextDouble() — дробного.\nЕщё одна команда next() позволяет считывать не строку целиком, а первое слово до пробела. Такие готовые типы позволяют собирать программу из фрагментов, как конструктор.\nВместо того чтобы описывать сложную логику для считывания символов из консоли, вы просто используете тип Scanner.\nВ Java есть очень много готовых типов. Для удобства они хранятся в разных папках, которые называются пакетами.\nЭто очень похоже на то, как файлы структурированы на жёстком диске компьютера: фотографии хранятся в папке с названием «Фото», а аудиофайлы — в «Музыке».\nПодобным образом организуют и код, только не по папкам, а по пакетам.\nЕсли тип хранится в каком-то пакете, то для того, чтобы его использовать, этот пакет сначала нужно импортировать (англ. import).\nТип Scanner хранится в пакете с названием java.util, и для того, чтобы использовать его в коде, нужно написать следующую команду:\n\nimport java.util.Scanner;\n\nТеперь вы сможете использовать тип Scanner и все его команды. Если попытаться запустить программу без import, произойдёт ошибка.\nПопробуйте запустить код ниже и убедитесь в этом.\n\n// Не импортировали пакет java.util.Scanner;\nimport java.util.Scanner;\npublic class Praktikum {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in); // Объявили переменную с типом Scanner\n        String command = scanner.nextLine(); // Считали строку из консоли\n        System.out.println(\"Вы ввели команду \" + command);\n    }\n}\n\nJava не знает, где искать Scanner, и сообщает нам об этом в сообщении об ошибке— java: cannot find symbol (англ. «не могу найти символ»).\nЕсли вернуть в код import, проблема исчезнет.\nВ следующих темах мы подробнее расскажем об объектах и разных готовых типах в Java и покажем, как с ними работать.\nМы добавили эту информацию сюда для того, чтобы вы уже сейчас смогли сделать вашу программу более отзывчивой на действия пользователя.\nМы всегда будем давать заготовку с кодом для считывания ввода в заданиях, но теперь вы будете понимать, что этот код означает.",
    "isLock": true
  },
  {
    "id": 43,
    "language": "Java",
    "title": "Урок 13. Цикл for: что есть что в цикле.",
    "text": "Отвлечёмся от повседневных дел и продолжим погружаться в азы Java. В этой теме вас ждёт знакомство с циклами. Они позволяют выполнять одно и то же действие несколько раз.\nК примеру, представим, вы завели хомяка. Грызуна зовут Байт, он любит есть морковки. Каждый день Байт съедает три морковки. Отразить это в коде можно так:\n\nSystem.out.println(\"Байт съел морковку.\");\nSystem.out.println(\"Байт съел морковку.\");\nSystem.out.println(\"Байт съел морковку.\");\n\nОтлично, всё работает, но что если Байт начнёт съедать в день по 10 морковок? Можно повторить строку кода нужное число раз, но тогда программа станет громоздкой.\nРазработчики вообще не любят дублировать код — это скучно и неудобно. Есть даже профессиональное правило DRY — Don't Repeat Yourself (англ. «не повторяй себя»).\nПоэтому в Java (и в других языках тоже) используются циклы — с их помощью действие выполняется нужное количество раз, но код при этом не дублируется.\nСуществует несколько типов циклов — они начинаются с разных служебных слов и применяются для разных задач.\nСначала мы подробно разберём цикл, который начинается со служебного слова for.\nОн используется тогда, когда число повторений известно заранее, — к примеру, сейчас мы знаем, что Байту нужно 10 морковок.\nКогда вы определили число итераций — повторений, которые должен выполнить цикл, нужно его настроить.\nПосле слова for в круглых скобках требуется задать стартовое значение цикла, условие его работы и порядок выполнения этого условия.\nОт этих трёх параметров зависит, откуда цикл начнёт свое движение, сколько раз выполнится и как будет меняться его начальное значение.\nПосле этого в фигурных скобках указывается тот участок кода, который нужно повторять, — он называется телом цикла.\nТолько после того, как цикл выполнит все итерации, заложенные в его условии, программа начнёт выполнять код, идущий следом. Всё вместе это выглядит так:\n\nfor (int i = 1; i <= 10; i = i + 1) {\n    System.out.println(\"Байт съел морковку.\");\n}\nSystem.out.println(\"Все морковки съедены. Морковок больше нет.\");\n\nСначала мы объявили переменную итерирования: с помощью неё настраивается количество повторов в цикле.\nИмя переменной вы выбираете сами, но традиционно её называют i — как и в нашем примере.\nНачальное значение равно единице (int i = 1) — именно с этой цифры ведётся отсчёт цикла.\nДалее идёт условие, при котором цикл будет работать. Так как Байт съест 10 морковок, условие такое: i <= 10.\nПока оно истинно — цикл выполняется, а значение переменной i пошагово изменяется.\nКогда условие задано, нужно отразить в настройках цикла, что за один подход хомяк съедает одну морковку.\nЭто выглядит так: i = i + 1 — значение переменной i при каждой итерации должно возрастать на единицу.\nВ теле цикла укажем текст, который нужно повторять — System.out.println(\"Байт съел морковку.\");\nКогда все итерации цикла будут выполнены, появится сообщение о том, что морковки съедены.\n\nЕсли требуется увеличить или уменьшить количество итераций, нужно изменить условие цикла.\nК примеру, десять морковок для Байта много — он сильно прибавил в весе.\nСнизим число морковок до пяти в день. В новом условии нужно отразить, что переменная итерирования i должна быть меньше или равна 5.\nДля контроля съеденного запишем все морковки. Для этого также можно использовать переменную итерирования — она доступна внутри цикла не только в его настройках,\nно и в теле (при этом не видна за пределами цикла).\nВ примере с Байтом значение переменной будет меняться при каждой итерации в последовательности от 1 до 5 — если поставить её в тело цикла,\nто будет учтена каждая морковка. Код получится таким:\n\npublic class Main {\n    public static void main(String[] args) {\n        for (int i = 1; i <= 5; i = i + 1) {\n            System.out.println(\"Байт съел \" + i + \"-ю морковку.\");\n        }\n    }\n}\n\nПеременная итерирования может принимать не только положительные значения или равняться нулю, но и быть отрицательной.\nПредположим, вы с Байтом решили переехать в новую квартиру и в вашем доме теперь есть подземная парковка (минус первый этаж) и даже лобби (нулевой этаж).\nВаша квартира находится на третьем этаже, и вам нужно подняться в неё на лифте с паркинга. В таком случае запрограммировать табло лифта можно так:\n\nfor (int i = -1; i <= 3 ; i = i + 1) {\n    System.out.println(\"Этаж \" + i);\n}\n\nНа экране будет напечатано:\nЭтаж -1\nЭтаж 0\nЭтаж 1\nЭтаж 2\nЭтаж 3\n\nЗадача 1.\nВы живёте на третьем этаже и вам нужно подняться на пятый к другу, чтобы вместе посмотреть футбольный матч.\nДопишите условие цикла так, чтобы его результат совпадал с приведённым ниже.\n\nРезультат:\nЭтаж 3\nЭтаж 4\nЭтаж 5\n\npublic class Main {\n    public static void main(String[] args) {\n        for (int i = ...; ... ; ...) {\n            System.out.println(\"Этаж \" + ...);\n        }\n    }\n}",
    "isLock": true
  },
  {
    "id": 44,
    "language": "Java",
    "title": "Урок 14. Цикл for: движение в обратном направлении и изменение шага.",
    "text": "Продолжаем. Весь прошлый урок вы работали с циклами, где переменная итерирования увеличивалась. Теперь представим, что вам нужно запрограммировать цикл for в обратном порядке.\nК примеру, на лифте можно не только подниматься, но и спускаться — номера этажей в таком случае отображаются по убыванию.\nКод цикла для лифта, который спускается с девятого на первый этаж, получится таким:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfor (int i = 9; i > 0 ; i = i - 1) {\n    System.out.println(\"Этаж \" + i);\n}\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nНачальное значение переменной итерирования i равно 9 — лифт начинает движение вниз с девятого этажа.\nПоскольку цикл должен завершиться, когда лифт доедет до первого этажа, в условии значение переменной i должно быть больше ноля либо больше или равно единице: i > 0 или i >= 1.\nНомера этажей уменьшаются, поэтому при каждой итерации требуется не прибавлять к i единицу, а отнимать — получится i = i - 1.\nРезультатом выполнения такого цикла будет:\n\nЭтаж 9\nЭтаж 8\nЭтаж 7\nЭтаж 6\nЭтаж 5\nЭтаж 4\nЭтаж 3\nЭтаж 2\nЭтаж 1\n\nЗапрограммировать цикл в обратном порядке не сложнее, чем в прямом. Кстати, для уменьшения переменной на единицу i = i - 1 можно использовать более простую запись: i-- — чем меньше кода, тем легче он читается и воспринимается. Операции i = i - 1 и i-- равнозначны.\nДля увеличения переменной i на единицу можно также использовать сокращённое выражение i++. На месте i может быть любая другая переменная.\n\nПеременная итерирования может меняться не только на единицу. Представим, что лифт перепроектировали. Теперь он останавливается только на нечётных этажах.\nПоявилась новая последовательность: вместо 1, 2, 3, 4, 5... стало 1, 3, 5, 7, 9.\nЧтобы запрограммировать такой лифт, нужно изменить шаг цикла — число, на которое после каждой итерации изменяется его переменная. Раньше был шаг 1, а теперь будет 2.\nЗаменим в коде операцию i = i + 1 на i = i + 2:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nfor (int i = 1; i <= 9 ; i = i + 2) {\n    System.out.println(\"Этаж \" + i);\n}\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nТеперь лифт будет открывать двери только на первом, третьем, пятом, седьмом и девятом этажах.\nМы можем сделать и так, чтобы он останавливался через каждые пять этажей (i = i + 5) — шаг цикла может быть любым числом. Его можно как увеличивать, так и уменьшать.",
    "isLock": true
  },
  {
    "id": 45,
    "language": "Java",
    "title": "Урок 15. Циклы с условием и вложенные циклы.",
    "text": "Вы уже немало знаете о циклах — умеете с их помощью печатать строки и проводить расчёты. Однако циклы не существуют в программе сами по себе.\nИх выполнение может зависеть от внешних обстоятельств.\nК примеру, благодаря советам ветеринара Байт отлично похудел к лету. Чтобы оставаться в форме, он решил устраивать разгрузочные дни.\nКаждое утро Байт взвешивается и определяет, будет ли он сегодня есть морковки или только попьёт воды и побегает в колесе.\nЕсли вес меньше 800 грамм, то Байт съедает как обычно пять морковок, в обратном случае объявляет разгрузочный день.\nЧтобы отразить это в коде, нужно добавить к циклу условное выражение:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\npublic class Main {\n    public static void main(String[] args) {\n        int weight = 750; // Объявили переменную веса Байта и присвоили ей значение\n        if (weight < 800) { // Цикл сработает, только если вес Байта меньше 800 грамм\n            for (int i = 1; i < 6; i = i + 1) {\n                System.out.println(\"Байт съел \" + i + \"-ю морковку\");\n            }\n        } else { \n            System.out.println(\"Разгрузочный день. Пьём водичку, крутим колесо!\");\n        }\n    }\n}\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nУра! Цикл с поеданием морковок запустится, только если вес Байта меньше 800 грамм. Поменяйте вес хомяка и позапускайте код — проверьте, что Байт точно не потолстеет!\nУсловные выражения и циклы часто используются вместе. Причём и цикл может находиться внутри условного выражения, как в примере с Байтом, так и условное выражение может быть внутри цикла.\n\nНаш ЗОЖ-хомяк решил не останавливаться на достигнутом и просит запрограммировать для него ещё и расписание пробежек в колесе.\nБайт решил, что следующие три дня хочет тренироваться по два раза — утром и вечером. Нужно учесть эти два параметра:\nчисло тренировочных дней и количество пробежек в день, и запрограммировать вот такое расписание:\n\nДень 1\n  Пробежка 1\n  Пробежка 2\nДень 2\n  Пробежка 1\n  Пробежка 2\nДень 3\n  Пробежка 1\n  Пробежка 2\n\nПопробуем справиться с помощью обычного цикла for с шагом в единицу:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nint days = 3; //Число дней с тренировками\nfor (int i = 1; i <= days; i++) {\n    System.out.println(\"День \" + i); // Смена дней происходит в цикле\n    System.out.println(\"Пробежка 1\"); \n    System.out.println(\"Пробежка 2\");\n} \n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nВроде получилось?! Дни тренировок теперь сменяются в цикле. Однако чтобы отображались пробежки, пришлось дублировать код, а как вы помните — Don't Repeat Yourself.\nПолучается, тренировки Байта тоже должны быть в цикле. И так как мы знаем их точное число, для этого также подойдёт цикл for.\n\nТаким образом, нам нужно, чтобы в цикле для смены дней запускался цикл с пробежками. То есть внутри одного цикла оказывается другой — он называется вложенным.\nВ коде это выглядит так:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\npublic class Main {\n    public static void main(String[] args) {\n\n\t\tint days = 3; // Количество дней, в которые Байт будет тренироваться\n\t\tint run = 2; // Число пробежек в день\n\t\t\t\t\n\t\tfor (int i = 1; i <= days; i++) { // Внешний цикл для смены дней\n\t\t\tSystem.out.println(\"День \" + i);\n\t\t\tfor (int j = 1; j <= run; j++) { // Вложенный цикл для пробежек с новой переменной\n\t\t\t\tSystem.out.println(\"  Пробежка \" + j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n}\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nЛогика этого кода следующая: сначала запускается внешний цикл, считающий дни. Программа печатает, что наступил первый день тренировки.\nПосле этого срабатывает вложенный цикл с пробежками — совершает две итерации и завершается. Снова запускается внешний цикл — наступил второй день тренировки.\nИ так далее. В результате вы получите то самое расписание тренировок, которое попросил у вас Байт, при этом копирования кода не потребовалось.\nПопрактикуйтесь. Измените значение переменных run и days — и посмотрите, как много разных тренировочных программ вы можете составить для Байта.\nОбратите внимание, переменную итерирования мы чаще всего называем i. Это не строгое правило, вы можете дать ей любое имя, но i — самое популярное.\nДля вложенного цикла, в свою очередь, самое распространённое имя —j.",
    "isLock": true
  },
  {
    "id": 46,
    "language": "Java",
    "title": "Урок 16. Цикл while.",
    "text": "Уф! Сколько всего вы уже знаете о циклах! Так держать — ещё пара уроков и вы станете настоящим профи в этой теме — краеугольной для любого разработчика.\nНа прошлых уроках мы много говорили о цикле for — он подходит для тех случаев, когда заранее известно количество итераций. Но так бывает не всегда.\nК примеру, вы закупили для Байта корм впрок — неизвестно, на сколько порций его хватит. В этом случае работа цикла будет определяться не числом повторений,\nа булевым выражением — питомец ест корм до тех пор, пока он в наличии. Если корм кончился — булево выражение стало ложным — цикл завершится.\nТакой цикл описывается с помощью служебного слова while (от англ. while — до тех пор, пока).\nВ цикле for мы определяли переменную итерирования, условие и шаг цикла. В цикле while нам неизвестно число итераций, поэтому не получится задать ни переменную, ни шаг.\nМы знаем только условие его работы. Его и указываем после слова while, перед телом цикла в фигурных скобках:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nint foodWeight = 500; // Количество корма\n\nwhile (foodWeight >= 10) { // Условие работы цикла - пока осталась хотя бы одна порция\n    foodWeight = foodWeight - 10; // Байт съедает 10 грамм корма за раз\n}\n\nSystem.out.println(\"Корм закончился! Пора идти в магазин!\");\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nСтруктура циклов for и while похожа, как и логика их работы — цикл выполняется, пока условие верно. В нашем примере цикл while будет работать до тех пор,\nпока значение переменной foodWeight больше или равно 10 — дома есть хотя бы одна порция корма. Как только переменная станет меньше 10 — цикл завершится.\nПосле этого будет выполнен следующий код — напечатано предупреждение, что пора идти в магазин.\n\nЦикл while также можно использовать для расчётов. К примеру, ваш друг хочет накопить 5000 рублей. Он не знает заранее, какую точно сумму сможет откладывать каждый день,\nно решил, что точно не больше 300 рублей. Эту задачу можно решить, соединив цикл while и генератор случайных чисел — Random.\nГенератор случайных чисел будет играть в коде роль вашего друга:\nопределять число в диапазоне от 0 до 300 — именно сколько денег будет отложено за день и сохранено в переменной moneyToday.\nЦикл while будет складывать эти деньги в копилку, суммируя их, и получать общую сумму накоплений moneyTotal.\nОдновременно while посчитает количество дней dayCount — то есть сколько итераций совершил цикл (сколько случайных чисел сгенерировал Random), чтобы получилось 5000.\nЭто выглядит так:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nimport java.util.Random;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Random random = new Random(); // Генерирует случайное число\n\n        int dayCount = 0; // Для учёта дней накоплений\n        int moneyTotal = 0; // Суммарное количество накоплений\n        int moneyToday; // Сколько откладываем сегодня\n        int goal = 5000; // Финансовая цель\n\n        while (moneyTotal <= goal) {\n            moneyToday = random.nextInt(300); // Случайная сумма на сегодня\n            moneyTotal = moneyTotal + moneyToday; // Добавили эти деньги в копилку\n            dayCount = dayCount + 1; // Засчитали день\n        }\n        System.out.println(\"Ура! Вы смогли накопить \" + goal + \" за \" + dayCount + \" дней.\");\n    }\n}\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nПозапускайте код и посмотрите, за сколько дней наберётся нужная сумма. Удастся ли вашему другу достичь своей финансовой цели за месяц? А за два?\nЦикл while удобно использовать, когда работа программы зависит от внешних данных, которые изначально неизвестны, — например, их вводит пользователь.\nДопустим, вы разрабатываете приложение-тренажёр по математике. Предполагается, что пользователь должен решать примеры с экрана и вводить свои ответы.\nЕсли ответ неправильный, то требуется повторять пример снова и снова — это и обеспечит терпеливый цикл while. В случае правильного ответа цикл завершится.\nПосмотрим, как это будет выглядеть в коде. Возьмём простой пример «Сколько будет 2+3?» и создадим цикл while, который будет предлагать пользователю решить его.\nНужно, чтобы цикл выполнялся до тех пор, пока не введён правильный ответ, равный 5. Чтобы отразить это в условии цикла, потребуется логический оператор «не равно» !=.\nОн работает так: если левая часть не равна правой, то условие истинно.\nНапример, 2 != 5 (два не равно пяти) — истинно, цикл продолжается, а 5 != 5 — ложно (пять равно пяти), цикл завершается.\nКроме того, для считывания ответа понадобится Scanner — введённое с консоли число будет храниться в переменной x.\nТаким образом, условие работы цикла получится таким — x != 5. Соединяем всё это:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nScanner scanner = new Scanner(System.in); // Позволяет считать ответ пользователя\nint x = 0; // Хранит ответ пользователя\n\nwhile (x != 5) { // Цикл выполняется, пока х не равна 5\n    System.out.println(\"Сколько будет 2+3?\");\n    x = scanner.nextInt(); // Считываем из консоли число и присваиваем переменной х\n}\nSystem.out.println(\"Пример решён правильно!\");\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nВ переменную x сохраняется число, которое вводит пользователь. Сначала ей присвоено значение 0 — пользователь ещё не ввёл ничего, однако это нужно, чтобы цикл заработал.\nВ теле цикла даём пример и считываем ответ пользователя с помощью выражения scanner.nextInt() — int внутри него означает,\nчто нужно считать из консоли именно числовое значение (если ввести буквенное, строку — будет ошибка).\nКак только пример решён (ответ правильный, условие ложно) — цикл завершится. Один из вариантов работы этого цикла может быть таким:\n\nСколько будет 2+3?\n6\nСколько будет 2+3?\n73\nСколько будет 2+3?\n5\nПример решён правильно!",
    "isLock": true
  },
  {
    "id": 47,
    "language": "Java",
    "title": "Урок 17. Бесконечный цикл.",
    "text": "Продолжаем изучать возможности цикла while. Он выполняется до тех пор, пока условие является истинным.\nСледовательно, если в условии написать true, то цикл будет выполняться снова и снова. Посмотрим, что получится, если запустить такой цикл для пробежки Байта в колесе.\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nwhile (true) { \n    System.out.println(\"Бегу, бегу, бегу!\"); // Будет выполняться бесконечно\n}\nSystem.out.println(\"Отлично побегал!\"); // Эта строка не будет напечатана\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nВ консоли будет беспрерывно печататься строка \"Бегу, бегу, бегу!\", а до строки \"Отлично побегал!\" очередь никогда не дойдёт.\nХомяк Байт в колесе превратился в вечный двигатель! Такой цикл, который начинается со служебного слова while и содержит в условии true, называется бесконечным.\nИ никакого символа бесконечности ∞ не требуется — его просто-напросто нет в синтаксисе Java.\nЕсли же написать в условии цикла false и попробовать запустить код, то вообще ничего не получится.\nПрограмма выдаст ошибку: unreachable statement (англ. «недостижимое утверждение»).\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nwhile (false) { \n    System.out.println(\"Никуда не побегу!\"); // Такой цикл не запустится. Хомяк решил поспать.\n} \n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nБесконечные циклы активно используются, например, при передаче данных, когда их объём неизвестен заранее.\nИли в построении web-приложений, которые общаются через не всегда надёжную сеть и могут «падать», и поэтому им требуется снова и снова отправлять друг другу запросы.\nПри работе с пользователями бесконечные циклы нужны, чтобы обеспечить беспрерывное ожидание и обработку таких операций, как касание экрана, свайпы или ввод текста и других.\nОднако Байт не хочет вечно бегать в колесе — вам нужно закончить цикл. Выйти из бесконечного цикла можно двумя способами, первый — остановить программу.\nНо это всё равно что сломать колесо — не очень практично. Более рационально использовать второй способ — добавить в код слово break (англ. «перерыв»).\nНа break цикл сразу завершится, а программа перейдёт к выполнению следующего кода. Байт сможет закончить пробежку и пойти перекусить. Это выглядит так:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nwhile (true) { \n    System.out.println(\"Бегу, бегу, бегу!\");\n    break; // Цикл завершился\n}\nSystem.out.println(\"Отлично побегал, пойду поем!\"); // Теперь эта строка будет напечатана\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nВ результате будет напечатано:\nБегу, бегу, бегу!\nОтлично побегал, пойду поем!\n\nБесконечный цикл с прерыванием break нужен, когда требуется выполнять условно неограниченное количество итераций до достижения определённого результата.\nНапример, при вызове такси в приложении радиус поиска свободной машины расширяется до тех пор, пока не найдётся первый подходящий автомобиль.\nОднако условий выхода из цикла (подходящих машин) может быть несколько, и в таком случае мы можем предложить пользователю выбор.\n\nЗадача 1.\n\nНакопления — дело серьёзное. Ваш друг уже накопил 5000 рублей и решил замахнуться на миллион. Для этого он положил свои сбережения на накопительный счёт под 5% годовых.\nДопишите программу с циклом while, которая посчитает, через сколько лет на счету будет нужная сумма.\nПредполагается, что стартовый баланс счёта (сумма сбережений) вводится с консоли.\n\n/////////////////////////////////////////////////////////////////////////\nimport java.util.Scanner;\n\nclass Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Сколько денег у вас сейчас: \");\n        double balance = scanner.nextDouble(); // Ваши сбережения\n        int years = 0;\n\n        while (...) {\n            balance = ...;\n            years = ...;\n        }\n\n        System.out.println(\"Через \" + ... + \" лет у вас будет миллион!\");\n    }\n}\n/////////////////////////////////////////////////////////////////////////",
    "isLock": true
  },
  {
    "id": 48,
    "language": "Java",
    "title": "Урок 18. Массивы: что это такое?",
    "text": "В вашем Java-портфеле теперь есть не только условные выражения, но и циклы! Уже, наверное, не терпится посмотреть вакансии джунов\n(так на профессиональном сленге называют начинающих или младших разработчиков). Ещё успеете. Лучше приступайте к новой теме — массивам.\nНа предыдущих уроках вы учились работать с переменными, которые содержали только одно значение — число или строку.\nНапример, названия валют в финансовом приложении хранятся в строковых переменных: у каждой валюты есть своя, отдельная.\nЧтобы работать с четырьмя валютами, нужно объявить четыре переменные. Только после этого можно их напечатать:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n// Объявляем все валюты по очереди\nString usd = \"USD\"; // Одна переменная — одна валюта\nString eur = \"EUR\";\nString jpy = \"JPY\";\nString rub = \"RUB\";\n\nSystem.out.println(\"Поддерживаемая валюта: \" + usd);\nSystem.out.println(\"Поддерживаемая валюта: \" + eur);\nSystem.out.println(\"Поддерживаемая валюта: \" + jpy);\nSystem.out.println(\"Поддерживаемая валюта: \" + rub);\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nПолучится:\nПоддерживаемая валюта: USD\nПоддерживаемая валюта: EUR\nПоддерживаемая валюта: JPY\nПоддерживаемая валюта: RUB\n\nЧтобы включить в этот список новые валюты, придётся создавать для каждой отдельную переменную. Это неудобно и долго, особенно если валют не четыре, а десятки или сотни.\nКроме того, код станет громоздким и работать с ним будет непросто.\nДля хранения однотипных элементов в Java используется специальная структура — массив (англ. array). Массив — это переменная, которая содержит несколько значений,\nотносящихся к одному типу данных. К примеру, если переменная с одним значением — это одна конфета, то массив — это коробка с конфетами.\nВ массивах удобно хранить большие объёмы однородных данных. Например, список телефонных номеров или адресов, свод физических характеристик:\nроста или веса, перечень географических координат, список дат, расходы за определённый промежуток времени и многое другое.\nС массивами гораздо удобнее работать в коде, чем с разрозненными переменными.\n\nОбъявление массива начинается с указания типа его значений. Массив хранит в себе значения только одного типа. Это может быть int, double, boolean, String или любой другой.\nДля хранения разных типов значений надо создавать разные массивы.\nОбъединить, например, значения типов int и boolean в одном массиве не получится — потребуется создать два разных.\nПосле указания типа данных идут квадратные скобки [] — это визитная карточка, отличительный знак массива, затем указывается его имя.\nПосле оператора присваивания = происходит инициализация массива — заполнение его значениями. Все значения необходимо перечислить в фигурных скобках {} через запятую.\nВот как будет выглядеть в коде массив для валют:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nString[] currencies = {\"USD\", \"EUR\", \"JPY\", \"RUB\"};\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nВместо четырёх переменных получилась одна переменная-массив.\nМассив называется currencies, хранит значения типа String (такой же тип был у переменных, которые он объединил) и содержит названия валют — доллара, евро, иены и рубля.\nПоздравляем! Теперь вы знаете, как заменить несколько однотипных переменных одним массивом. На следующем уроке вы научитесь работать с его значениями.",
    "isLock": true
  },
  {
    "id": 49,
    "language": "Java",
    "title": "Урок 19. Учимся работать с массивами: индексы и элементы.",
    "text": "На прошлом уроке вы научились преобразовывать список однотипных переменных в единый массив, внутри которого теперь собраны все их значения.\nОднако массив был бы бесполезен, если бы с его данными нельзя было взаимодействовать.\nЕсли представить, что массив — это коробка со множеством отделений, то у каждого из этих отделений есть свой идентификационный номер. Как у почтовых ящиков в вашем подъезде.\nЧтобы взять письмо из ящика, нужно знать его номер.\nНомер каждого почтового ящика в массиве называется индексом, а его содержимое — значение, которое там хранится — элементом. Если требуется извлечь из массива определённый\nэлемент, надо указать его индекс. К примеру, на прошлом уроке мы создали массив с валютами:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nString[] currencies = {\"USD\", \"EUR\", \"JPY\", \"RUB\"};\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nЧтобы получить конкретный элемент, нужно указать имя массива и индекс элемента в квадратных скобках.\nПолученный элемент можно вывести на экран:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nString[] currencies = {\"USD\", \"EUR\", \"JPY\", \"RUB\"};\nSystem.out.println(\"Вы выбрали валюту: \" + currencies[1]);\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nРезультат будет таким:\n\nВы выбрали валюту: EUR\n\nИндексация массива всегда начинается с нуля, а не с единицы. В нашем массиве из четырёх валют у доллара индекс будет 0, а у рубля — 3. А под индексом 1 хранятся евро.\n\nЗначение любого элемента в массиве можно изменить. Для этого сначала понадобится найти нужный элемент через его индекс (например, доллары — currencies[0]),\nа потом с помощью оператора присваивания = задать ему новое значение (пусть это будут швейцарские франки).\nМожно заменить хоть все валюты, важно при обращении к ним не перепутать индексы:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nclass Main {\n    public static void main(String[] args) {\n        String[] currencies = {\"USD\",\"EUR\",\"JPY\",\"RUB\"};\n\n        // Выводим список поддерживаемых валют\n        System.out.println(\"Список поддерживаемых валют:\");\n        System.out.println(currencies[0]);\n        System.out.println(currencies[1]);\n        System.out.println(currencies[2]);\n        System.out.println(currencies[3]);\n\n        System.out.println(\"Не везде пригодятся: \" + currencies[0]);\n        currencies[0] = \"CHF\";\n        System.out.println(\"В Швейцарии в обращении: \" + currencies[0]);\n\n        System.out.println(\"В Дании не примут: \" + currencies[1]);\n        currencies[1] = \"DKK\";\n        System.out.println(\"Там нужны: \" + currencies[1]);\n\n        System.out.println(\"Зачем нам в Китае: \" + currencies[2]);\n        currencies[2] = \"CNY\";\n        System.out.println(\"Купим: \" + currencies[2]);\n\n        System.out.println(\"В Белоруссии родные: \" + currencies[3]);\n        currencies[3] = \"BYN\";\n        System.out.println(\"Поменяю на местные: \" + currencies[3]);\n\n        // Теперь список поддерживаемых валют другой\n        System.out.println(\"Новый список поддерживаемых валют:\");\n        System.out.println(currencies[0]);\n        System.out.println(currencies[1]);\n        System.out.println(currencies[2]);\n        System.out.println(currencies[3]);\n    }\n}\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nОбновлённый массив выглядит так: {\"CHF\", \"DKK\", \"CNY\", \"BYN\"}. Все первоначальные элементы заменены на новые. В массиве есть швейцарские франки, датские кроны,\nкитайские юани и белорусские рубли, а вот долларов, евро, иен и российских рублей больше нет.\nПоэкспериментируйте с кодом, выберите новые значения валют и замените значения элементов.\nУра! Теперь вы умеете взаимодействовать с данными массива.",
    "isLock": true
  },
  {
    "id": 50,
    "language": "Java",
    "title": "Урок 20. Знакомимся с длиной массива.",
    "text": "Создать массив легко, если его содержание заранее известно. Например, в массиве с валютами было определено и количество элементов — четыре, и значение каждого элемента.\nТак бывает не всегда.\nПредставьте такую ситуацию: продюсер решил создать музыкальную группу и точно знает, что возьмёт четверых музыкантов.\nВыступление группы анонсировано — её уже обсуждают, но кастинг не проведён и конкретные исполнители не выбраны.\nАналогично в Java можно создать массив, где известно точное число элементов, но их конкретные значения не определены.\nЧтобы создать массив, в котором не определены значения элементов, нужно указать его размер.\nРазмер, или длина (англ. length), массива — это количество элементов, которые он содержит. У массива всегда должен быть задан размер.\nЕсли все элементы массива уже указаны в фигурных скобках, то его длина будет вычислена автоматически, по их количеству.\nЕсли создаётся массив без значений, то нужно указать его размер напрямую — без этого ничего не получится. После того как массив создан, изменить его размер невозможно.\nСоздание массива через длину частично похоже на объявление массива с известными элементами.\nСначала указывается тип данных, которые будут содержаться в массиве, квадратные скобки [] и название массива — например, String[] currencies.\nОднако после оператора присваивания = не будет фигурных скобок и перечисления элементов. Там используется ключевое слово new (англ. «новый»),\nещё раз указывается тип значений будущих элементов и в квадратных скобках определяется размер массива: например, new String[4].\nКлючевое слово new в Java используется достаточно часто — вы ещё не раз с ним встретитесь. Оно означает, что создаётся новое значение сложного типа.\nК сложным типам в Java относятся, например, уже знакомые вам scanner и генератор случайных чисел random.\nА такие типы, как int, double, boolean считаются примитивными, для создания их значения слово new не используется.\nПосле того как вы с помощью ключевого слова new создали новый массив и определили его размер, можно наполнить его элементами.\nДля этого нужно вызвать каждый элемент по его индексу и присвоить ему содержание. С этим действием вы уже знакомы:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nString[] currencies = new String[4]; // Создан массив, в котором должно быть четыре валюты\n\ncurrencies[0] = \"USD\"; // Определили первую валюту, записали её в массив\n// Определили остальные валюты\ncurrencies[1] = \"EUR\";\ncurrencies[2] = \"JPY\";\ncurrencies[3] = \"RUB\";\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nПрисваивать значения элементам можно в любом порядке. Между объявлением массива и его пошаговой инициализацией могут быть другие операции или команды:\nнапример, вычисления или ввод значений элементов с консоли. Когда всем элементам массива присвоено значение, у вас получится такой же массив,\nкак если бы он был инициализирован с помощью фигурных скобок.\nПри работе с массивами важно знать некоторые особенности их построения в коде. К примеру, пустой массив нужной длины можно задать не только одной строкой,\nно и в два шага:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nString[] currencies = new String[4]; // Можно задать массив так\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\n// А можно так:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nString[] currencies; // Объявили переменную-массив, её ещё нельзя использовать\ncurrencies = new String[4]; // Массив готов к использованию, его элементы пока пусты\n// Далее заполняем массив значениями\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nА вот создать массив с известными заранее значениями элементов можно только одной строкой — иначе произойдёт ошибка:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nString[] currencies = {\"USD\", \"EUR\", \"JPY\", \"RUB\"}; // Массив готов и проинициализирован\nString[] currencies; // Разбить на две строки не получится\ncurrencies = {\"USD\", \"EUR\", \"JPY\", \"RUB\"}; // Произойдёт ошибка\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nПредставим, что в вашем распоряжении есть вот такой проинициализированный массив, размер которого нужно узнать:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nString[] currencies = {\"USD\", \"EUR\", \"JPY\", \"RUB\", \"THB\", \"UAH\", \"MAD\", \"SGD\", \"AMD\", \"DKK\", \"CZK\", \"SEK\", \"TRY\", \"KZT\", \"CHF\"};\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nСчитать длину массива вручную долго и неудобно. Кроме того, можно легко ошибиться. Вычислить количество элементов можно с помощью свойства массива length (англ. «длина»).\nВ окружающем нас мире у всех объектов есть свои свойства: у красок — цвет, у автомобилей — мощность, у котов — вредность и пушистость.\nУ программных составляющих сложных типов (сканера, массива и других) тоже есть свойства — с их помощью можно получить нужную информацию о них.\nВ частности, узнать длину массива можно, обратившись к его свойству length. Механика проста: имя_массива.length.\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nclass Main {\n    public static void main(String[] args) {\n        String[] currencies = {\"USD\", \"EUR\", \"JPY\", \"RUB\", \"THB\", \"UAH\", \"MAD\", \"SGD\", \"AMD\", \"DKK\", \"CZK\", \"SEK\", \"TRY\", \"KZT\", \"CHF\"};\n        int currenciesCount;\n        currenciesCount = currencies.length;\n\n        System.out.println(\"Сколько валют в приложении?\");\n        System.out.println(currenciesCount);\n    }\n}\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nВ результате выполнения программы мы узнаем, что всего в массиве 15 элементов. Добавьте в него или удалите из него значения валют и посмотрите, как изменится его длина.\nСпособ создания массива не влияет на его свойства, поэтому получить длину через length можно и тогда, когда она задаётся заранее (при создании массива через new).",
    "isLock": true
  },
  {
    "id": 51,
    "language": "Java",
    "title": "Урок 21. Массивы и циклы.",
    "text": "В этой теме мы много работаем с массивом валют, и нам не раз нужно было напечатать его элементы. Чтобы это сделать, приходилось использовать в коде несколько однотипных строк:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nString[] currencies = {\"USD\", \"EUR\", \"JPY\", \"RUB\"};\nSystem.out.println(\"Поддерживаемая валюта: \" + currencies[0]);\nSystem.out.println(\"Поддерживаемая валюта: \" + currencies[1]);\nSystem.out.println(\"Поддерживаемая валюта: \" + currencies[2]);\nSystem.out.println(\"Поддерживаемая валюта: \" + currencies[3]);\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nРезультат этого кода вы тоже много раз видели:\nПоддерживаемая валюта: USD\nПоддерживаемая валюта: EUR\nПоддерживаемая валюта: JPY\nПоддерживаемая валюта: RUB\n\nОднако если массив будет состоять не из четырёх, а из ста элементов, то придётся напечатать целых сто похожих строк кода! Но много повторяющегося кода это моветон. Вы же помните правило — Don't Repeat Yourself!\n\nЧаще всего для работы с массивами используется цикл for.\nЭто логично, ведь число элементов массива (его размер) — это и есть число будущих итераций цикла, и оно известно заранее.\nДля того чтобы напечатать все элементы массива, вызовем их по очереди с помощью переменной итерирования — поставим её на место индекса.\nЦикл будет начинаться с нуля, так как ноль — стартовый индекс в любом массиве. Шаг цикла сделаем равным единице: так мы не пропустим ни одного элемента.\nЦикл должен работать до тех пор, пока не напечатаны все значения массива. Чтобы задать это условие, потребуется указать длину массива — получим её с помощью свойства length.\nВсё вместе в коде это будет выглядеть так:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nclass Main {\n    public static void main(String[] args) {\n        String[] currencies = {\"USD\", \"EUR\", \"JPY\", \"RUB\"}; // Массив\n        // Цикл начинается с 0 и продолжается c шагом в единицу, пока i строго меньше длины массива\n        for (int i = 0; i < currencies.length; i++) {\n            // Переменная итерирования ставится на место индекса, так все элементы будут напечатаны\n            System.out.println(\"Поддерживаемая валюта: \" + currencies[i]);\n        }\n    }\n}\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nОбратите внимание, что индекс последнего элемента всегда на единицу меньше длины массива. К примеру, в массиве из четырёх элементов индекс последнего будет 3.\nПоэтому в условии цикла обычно используется знак строгого сравнения — i < currencies.length.\nМожно задать условие работы цикла и через знак нестрогого сравнения «меньше или равно» <=. Нужно просто не забыть отнять от длины массива единицу.\nПопробуйте сделать это и убедитесь, что результат не изменится.\nРезультат работы программы при использовании цикла останется таким же, как и при дублировании строк.\nНо теперь код будет выглядеть корректно, особенно если массив станет больше.",
    "isLock": true
  },
  {
    "id": 52,
    "language": "Java",
    "title": "Урок 22. Выход за границы массива.",
    "text": "Вы уже немало знаете о массивах — умеете их создавать, получать их элементы по индексу и присваивать им новое значение.\nОтлично усвоили, что нумерация в массиве начинается с нуля, а его размер всегда задаётся в момент создания.\nОсталось разобраться, что произойдёт, если попытаться вызвать элемент массива за пределами его длины.\nНапример, попробуем запросить пятый элемент из массива с четырьмя валютами:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nclass Main {\n    public static void main(String[] args) {\n        // 4 валюты, их индексы в массиве — от 0 до 3\n        String[] currencies = {\"USD\", \"EUR\", \"JPY\", \"RUB\"}; \n        int index = 4;\n        System.out.println(currencies[index]); // Пытаемся получить элемент с индексом 4 \n    }\n} \n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nЕсли попробовать запустить этот код, то в консоли появится следующее сообщение об ошибке:\n\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index 4 out of bounds for length 4\n    at Main.main(Praktikum.java:5) \n\nПервое слово в сообщении <Exception>, значит, произошло исключение. Оно называется ArrayIndexOutOfBoundsException, что означает «ошибка выхода за границы массива».\nГраницы массива программа определяет как 0 и length - 1 — длина минус единица.\nУказанное исключение произойдёт, если в качестве индекса использовались числа меньше нуля и больше длины, то есть за пределами границ.\n\nВыход за границы массива — частая ошибка при вводе индекса пользователем. Возьмём традиционный пример с массивом из четырёх валют,\nгде мы просим пользователя выбрать одну из них:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nString[] currencies = {\"USD\", \"EUR\", \"JPY\", \"RUB\"};\nScanner scanner = new Scanner(System.in);\n\nSystem.out.println(\"Введите индекс валюты, которую хотите напечатать, от 0 до 3:\");\nint index = scanner.nextInt(); // Считываем ввод пользователя \n\nSystem.out.println(\"Поддерживаемая валюта: \" + currencies[index]); \n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nЕсли пользователь выберет любое число меньше нуля или больше трёх, то в консоли появится сообщение с ArrayIndexOutOfBoundsException.\nОшибки выхода за границы массива можно избежать с помощью ветвления.\nКонструкция с условными выражениями позволит проверить, подходит ли введённый пользователем индекс для получения элемента из массива:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nString[] currencies = {\"USD\", \"EUR\", \"JPY\", \"RUB\"};\n\nScanner scanner = new Scanner(System.in);\nSystem.out.println(\"Введите номер валюты, которую хотите купить:\");\nint index = scanner.nextInt(); // Даём пользователю ввести индекс и считываем его ввод\n\nif (index < 0) {\n    // Если индекс меньше 0, сообщаем пользователю об ошибке\n    System.out.println(\"Неверное значение номера валюты! Выберите число от 0 до 3.\");\n} else if (index >= currencies.length) {\n    // Индекс должен быть строго меньше длины массива\n    System.out.println(\"Неверное значение номера валюты! Выберите число от 0 до 3.\");\n} else {\n    // Всё хорошо, выводим запрошенную пользователем валюту\n    System.out.println(\"Вы купили валюту: \" + currencies[index]);\n} \n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nТеперь при выборе индекса за границами массива программа не перестанет работать, а пользователь получит корректное сообщение об ошибке.",
    "isLock": true
  },
  {
    "id": 61,
    "language": "CPlusPlus",
    "title": "Урок 1. Что такое C++ и зачем он нужен",
    "text": "C++ (читается си-плюс-плюс) — это мощный и современный язык. Он незаменим там, где нужна высокая производительность: компьютерные игры, работа с изображениями, видео и аудио.\nНа C++ также пишут высоконагруженные сервисы, поисковые системы, драйверы устройств, операционные системы, компиляторы других языков программирования.\n3D-движки написаны на C++ или его старшем брате — C.\nПорой программа пишется на другом языке, но критические с точки зрения производительности места доверяют C или C++.\nНа этих языках программируют микроконтроллеры, используемые, например, в дронах и 3D-принтерах. Но C++ замечательно подходит и для решения более простых повседневных задач.\nСтарый добрый язык C во многом совместим с C++. Изучив C++, можно программировать и на C — если изучить некоторые особенности. Выпускникам курса «‎Разработчик С++»‎ это под силу.\nГлавное преимущество C++ — сфера его применения не имеет ограничений. Пройдя курс и овладев этим языком, вы сможете писать практически любые приложения.\nC++ мог быть вообще вне конкуренции, если бы не один минус: это сложный язык, и быстро его не освоить. Но раз вы выбрали C++, значит, у вас большие амбиции.\nДобавьте целеустремлённость и немного терпения, и у вас всё получится. Мы в вас верим!\n\nЗнакомство с языком программирования начинается с программы, выводящей текст “Hello world”. На C++ это будет так:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ncout << \"Hello world!\"s << endl;\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nЧтобы запустить эту программу, нужно сначала перевести её из человекочитаемого вида в тот, который понятен процессору. То есть преобразовать из исходного кода в двоичный.\nДелает эту работу специальная программа — компилятор.\nПеред уроком говорилось, что в курсе будут задания, которые можно выполнять в онлайн-компиляторе или в среде разработки. Но перед этим мы расскажем о синтаксисе языка,\nбез которого нельзя будет запустить программу. О нем вы узнаете в следующих уроках.",
    "isLock": false
  },
  {
    "id": 62,
    "language": "CPlusPlus",
    "title": "Урок 2. Кратко о главном — функция main",
    "text": "Начнём по порядку. Расскажем про функцию main. Так выглядит ее объявление:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nint main() {\n}\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nmain — это точка входа программы. Та функция, которая запускается первой. Завершение main означает завершение всей программы. Она вызывается только один раз. Код из заданий\nнужно будет вставлять в фигурные скобки, то есть внутрь функции main. Попробуйте открыть онлайн-компилятор. Скорее всего Вы увидите что-то похожее на это:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n#include <iostream>\n\nint main()\n{\n    std::cout<<\"Hello World\";\n\n    return 0;\n}\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nили на это:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    cout<<\"Hello World\";      (1\n\n    return 0;\n}\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nДалее мы разберем все, что тут написано. А пока попробуйте вставить следующий код, вместо строки, которая выделена единицей:\n\n----------------------------------------------\nstd::cout<<\"Привет, я уже программа!\" << endl;\n----------------------------------------------\n\nВ консоль вывелось сообщение \"Привет, я уже программа!\". Так держать!",
    "isLock": true
  },
  {
    "id": 63,
    "language": "CPlusPlus",
    "title": "Урок 3. Импорт библиотек и пространство имен.",
    "text": "Другая важная часть программы — импорт библиотек. Он делается в начале программы include-директивами:\n\n\\\\\\\\\\\\\\\\\\\\\n#include <iostream>\n\\\\\\\\\\\\\\\\\\\\\\\n\nКаждая директива include пишется на отдельной строке. В этом коде импортированы стандартная библиотека C++: iostream, имя которой заключено в угловые скобки.\nПеречислим библиотеки для частых имен, которых вы встретите:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ncout, cin, endl — iostream.\nfixed, setprecision — iomanip.\nvector — vector.\nstring, строковые литералы — string.\nsin, hypot, sqrt и прочие математические функции — cmath.\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nЧтобы вышеобозначенные имена из библиотек стали доступны, нужна ещё одна конструкция: using namespace std. Она пишется обычно сразу после include-директив.\nПолностью программа может выглядеть так:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    cout << \"Hello, C++ ^_^\"s << endl;\n} \n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nОбратите внимание, что после using namespace std нужна точка с запятой, а после include-директивы — нет. Это связано с тем, что include-директивы обрабатываются на\nпредварительном этапе компиляции, который называется препроцессированием.\nusing namespace std можно не писать, но тогда каждое имя из стандартной библиотеки C++ нужно предварять так называемой квалификацией, например std::cin, std::endl.\n\nСкорее всего, сейчас это сложно понять, но не бойтесь, во время прохождения курса будут подсказки, чтобы Вы быстрее освоились.",
    "isLock": true
  },
  {
    "id": 64,
    "language": "CPlusPlus",
    "title": "Урок 4. Программируем на C++",
    "text": "Посмотрим на код, который вы недавно запускали.\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ncout << \"Привет, я уже программа!\" << endl;\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nНачинается он со слова cout (читается «‎си-аут»‎), которое обозначает стандартный поток вывода. Ведь прежде, чем вывести текст, нужно сообщить, куда его вывести.\nМы решили вывести в окно терминала и выбрали cout. При запуске этой программы на компьютере текст появится в окне консоли.\nДругим примером места, куда можно вывести информацию, будет файл, канал связи в сети, звуковой канал наушников или другая программа.\nПри этом команды вывода не поменяются. Это — универсальный интерфейс.\nСлово cout надо написать маленькими буквами, иначе при компиляции возникнет ошибка. В C++ регистр символов имеет значение.\nДанные в поток направляются операцией <<. Первое, что мы отправили в этой маленькой программке, — строка \"Привет, я уже программа!\".\nЧтобы показать компилятору, что это не код на C++, а текст на понятном нам языке, нужно заключить строку в двойные кавычки. В таком случае компилятор не будет пытаться\nразобрать команды, а просто аккуратно, символ за символом, прочитает и сохранит всё, что написано внутри кавычек.\n\nВторое, что мы вывели в поток, — объект endl (читается «эндл»). Он вполне соответствует названию — всё, что выведено в поток после него, будет напечатано с новой строки:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ncout << \"Привет, я уже программа!\" << endl << \"Как ваши дела?\" << endl;\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nТакой код содержит два endl, а значит, на выводе будет уже две строки:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\nПривет, я уже программа!\nКак ваши дела?\n\\\\\\\\\\\\\\\\\\\\\\\\\\n\nКажется, что последний endl не имеет смысла, ведь после него ничего не выведено. Но, тем не менее, завершать строку после каждого вывода — хороший тон.\n\nИ последнее, что есть в программе, — точка с запятой. Это обязательный знак, им завершается оператор. В C++ опускать точку с запятой нельзя,\nнедостаточно просто начать писать новую команду с новой строки.\nЧтобы написать команду вывода, понадобились латинские буквы, запятая, плюс и знак пробела. А ещё некоторые спецсимволы, которые имеют особое значение в C++.\n\nДавайте посмотрим, какие спецсимволы использовались:\n• < — знак «меньше». Из него сформирована операция << вывода в поток.\n• \" — двойная кавычка. В них мы заключили строку, чтобы показать, что это не команды C++.\n• ; — точка с запятой. Обозначает конец оператора.\nВ прошлом задании вы только запускали готовую программу, пора написать свою!\n\nЗадание 1.\nПо аналогии с предыдущим заданием напишите программу, выводящую в поток стандартного вывода текст Happy coding!. После строки в поток нужно вывести endl.\nЕсли вы напишете что-нибудь не так, компилятор выдаст сообщение об ошибке. Мы разберём их в одном из следующих уроков.\nПопробуйте не копировать команду, а набрать её самостоятельно. Мы подготовили заготовку — скопируйте ее и допишите программу в онлайн-компиляторе.\n\n--------------------------\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n//дополните эту строчку:\n    cout <<  << endl;\n\n    return 0;\n}\n--------------------------",
    "isLock": true
  },
  {
    "id": 65,
    "language": "CPlusPlus",
    "title": "Урок 5. Один оператор хорошо, а много — лучше!",
    "text": "Вряд ли настоящая программа будет состоять из одной команды. Для вас хорошие новости — количество команд не ограничено.\nРеальные программы содержат тысячи, десятки тысяч и даже миллионы строк:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n// Выводим две строчки\ncout << \"To be, or not to be,\" << endl;\ncout << \"that is the question\" << endl;\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nКод выведет такой текст:\n\n\\\\\\\\\\\\\\\\\\\\\nTo be, or not to be,\nthat is the question\n\\\\\\\\\\\\\\\\\\\\\\\n\nПрограммисты называют команды операторами. Но в курсе будем стараться избегать этого термина. Не только потому, что слово «команда»‎ проще,\nно и потому, что может возникнуть путаница. Совсем скоро вы изучите операции. Они такие же, как в математике: плюс, минус, умножить, равно.\nНо есть и специфические, встречающиеся только в программировании.\n\nКомментарии\nПервая строка в коде выше необычная, она начинается со знака //. Это комментарий — часть кода, предназначенная не для компилятора, а для другого программиста,\nчитающего этот код. В C++ есть два вида комментариев:\n• Однострочный. Он начинается с // и продолжается до конца строчки:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  // Выводим две строчки\n  cout << \"To be, or not to be,\"s << endl; // первая строчка\n  cout << \"that is the question\"s << endl; // вторая строчка\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nЕго вы могли заметить в предыдущем уроке в задании.\n\n• Многострочный. Он может занимать несколько строчек, заключённых между знаков /* и */:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  /*\n     Цитата из трагедии Уильяма Шекспира «‎Гамлет».\n     Акт III сцена I.\n     Гамлет, Офелия, Полоний, Король.\n  */\n  cout << \"To be, or not to be,\"s << endl;\n  cout << \"that is the question\"s << endl;\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nВидя комментарий, компилятор понимает, что этот текст не для него и пропускает часть кода.\nЗабавно, что использование комментария часто не соответствует его виду.\n\n• Однострочный комментарий используют для длинных пояснений:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  // Цитата из трагедии Уильяма Шекспира \"Гамлет\".\n  // Акт III сцена I.\n  // Гамлет, Офелия, Полоний, Король.\n\n  cout << \"To be, or not to be,\"s << endl;\n  cout << \"that is the question\"s << endl;\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\n• А многострочный — для маленького пояснения внутри строки:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  cout << /* строка */ \"To be, or not to be,\"s << /* манипулятор */ endl;\n  cout << /* строка */ \"that is the question\"s << /* манипулятор */ endl;\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nЭкранирование\n\nЕсли вы просто напишете \", компилятор решит, что строка закончилась. Чтобы всё-таки разместить знак кавычки, перед ним ставят символ \\.\nЭто действие называется экранированием — мы показываем компилятору, что следующий знак имеет специальное значение:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ncout << \"Quote from \\\"Hamlet\\\":\" << endl;\ncout << \"To be, or not to be,\" << endl;\ncout << \"that is the question\" << endl;\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nРезультат:\nQuote from \"Hamlet\":\nTo be, or not to be,\nthat is the question\nКак видно, символ \\ бесследно исчез.\n\nПроблемы возникнут с самим знаком экранирования. Вместо того чтобы поместить его в строку, компилятор будет анализировать следующий символ.\nЧтобы вставить \\ внутрь строки, надо перед ним поставить ещё один символ \\:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ncout << \"Используйте символ \\\\ для экранирования \\\" и самого \\\\\"s << endl;\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nРезультат:\nИспользуйте символ \\ для экранирования \" и самого \\\n\nЗадание 1\nПеред вами робот-спасатель RS-99. Во всяком случае, так его увидел художник-абстракционист Бенедикт Хант, впечатлённый работой машины.\n_____________\n|  /\"\"\"\"\"\\  |\n| /       \\ |\n| | 0   0 | |\n| |   v   | |\n| \\  ___  / |\n|  \\_____/  |\n-------------\nХант считает, что кисти и краски не для прогрессивных художников, и настоящий портрет машины может создать только машина.\nДля выставки Ханту понадобилась соответствующая программа. Напишите программу для воспроизведения этого рисунка.\nВ каждой из восьми строк рисунка 13 символов. Учтите: верх рамки, рот и подбородок нарисован знаками подчёркивания.\nНиз рамки — минусами. Волосы выполнены двойными кавычками, глаза — нулями, а нос — буквой v.\n\nТребования\n• Каждую строку рисунка выводите отдельной командой, начинающейся с cout и заканчивающейся ;.\n• Воспроизведите рисунок в точности. Не выводите лишних пробелов и символов. Для упрощения работы можете скопировать его из условия.\n• Аккуратно экранируйте специальные символы в рисунке.\n• Рамка тоже относится к рисунку.\n\nЗаготовка:\n\n--------------------\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    \n    return 0;\n}\n--------------------",
    "isLock": true
  },
  {
    "id": 66,
    "language": "CPlusPlus",
    "title": "Урок 6. Лучшие друзья разработчика — это ошибки",
    "text": "Выполняя предыдущие задания вы, вероятно, уже сталкивались с ними — ошибками компиляции. Это загадочные сообщения на английском языке, которые иногда появляются в \nокне результата при запуске или проверке программы.\nC++ славится запутанными сообщениями об ошибках, но к концу курса вы научитесь понимать их и, конечно, исправлять. Если пока что вам удавалось избежать ошибок, \nпримите поздравления — вы отлично усваиваете материал!\nРассмотрим пример:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ncout << \"Very nice day!\" << endl \n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nКазалось бы, корректный код, но компилятор выдаёт сообщение:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n/exposed/submission/submission.cpp: In function ‘int main()’:\n/exposed/submission/submission.cpp:6:37: error: expected ‘;’ before ‘}’ token\n    6 |     cout << \"Very nice day!\" << endl\n      |                                      ^\n      |                                      ;\n    7 | }\n      | ~\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nСуть ошибки указана после слова error: expected ‘;’ before ‘}’ token. Компилятор прямо говорит нам: вставьте знак ;.\n«Глупый компилятор, — можете подумать вы, — раз он сам знает, что ему нужна точка с запятой, почему бы просто не считать, что она там есть?»‎. \nИ действительно, поначалу ошибки будут сильно мешать. На первый взгляд совершенно непонятно, почему компилятор отказывается собирать программу, \nесли так очевидно, что имеется в виду.\nТолько набравшись опыта, вы узнаете, что сообщения об ошибках — не враги разработчика, а его друзья. Они помогают выявить проблему до того, \nкак программа попала к пользователю.\nПопробуем ошибиться по-другому, пропустим операцию вывода в поток:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ncout \"Very nice day!\" << endl;\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nКомпилятор, тем не менее, продолжает вторить уже знакомое:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n/exposed/submission/submission.cpp:6:9: error: expected ‘;’ before string constant\n    6 |     cout  \"Very nice day!\" << endl;\n      |         ^ ~~~~~~~~~~~~~~~~\n      |         ;\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nДа, как выясняется, компилятор — не оракул. Догадаться, какая именно операция пропущена, он не может. Поэтому предлагает просто завершить команду. \nСделайте из этого важный вывод: \nНе стоит сразу делать то, что советует компилятор. При появлении ошибки нужно вначале разобраться, в чём её причина, и только потом исправлять.\n\nУ разработчиков есть друзья помимо сообщений об ошибках. Знакомьтесь — warning. Предупреждения выдаются, когда программа синтаксически корректна и может \nскомпилироваться, но компилятору что-то кажется подозрительным. Аккуратный программист всегда исправляет их. \n\nРассмотрим пример:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ncout ; \"Happy coding\" ; endl; \n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nВ нём по ошибке написаны ; вместо <<. Такая программа допустима, но она состоит из трёх команд, которые ничего не делают. Это кажется компилятору подозрительным, и он выдаст следующее:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n/exposed/submission/submission.cpp: In function ‘int main()’:\n/exposed/submission/submission.cpp:6:5: error: statement has no effect [-Werror=unused-value]\n    6 |     cout ; \"Happy coding\"s ; endl;\n      |     ^~~~\ncompilation terminated due to -Wfatal-errors.\ncc1plus: all warnings being treated as errors \n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nСуть сообщения — statement has no effect. Далее компилятор указывает, что это стало ошибкой, потому что мы попросили считать все предупреждения ошибками.\nКонечно, в реальной разработке эту настройку можно отключить. Но тогда вы рискуете пропустить ошибку, и пользователь столкнётся с неправильно работающей программой. \nПодумайте, стоит ли оно того.\n\nЗадание 1.\nИсправьте ошибки в программе, которая дана в заготовке кода.\n\nТребования\nПосле исправления ошибок должна получиться программа, выводящая такой текст:\n\nThe quote from \"Hamlet\":\nTo be, or not to be, that is the question:\nWhether 'tis nobler in the mind to suffer\nThe slings and arrows of outrageous fortune,\nOr to take arms against a sea of troubles\nAnd by opposing end them.\n\nНе перепечатывайте и не копируйте текст. Ваша задача — исправить код, данный в заготовке. Скопируйте код и вставьте в онлайн компилятор в одну из прошлых заготовок.\n\n------------------------------------------------------------\ncout << \"The quote from \"Hamlet\":\" << endl;\ncout \"To be, or not to be, that is the question:\" endl\ncout << Whether 'tis nobler in the mind to suffer << Endl\ncout << \"The slings and arrows of outrageous fortune,\" endl;\ncout << \"Or to take arms against a sea of troubles\" << endl;\ncont << \"And by opposing end them.\" << end;\n------------------------------------------------------------",
    "isLock": true
  },
  {
    "id": 67,
    "language": "CPlusPlus",
    "title": "Урок 7. Переменные",
    "text": "Программирование — оперирование данными. Даже изображение на экране монитора — это данные. Изображение состоит из точек, цвет которых задаётся числами в памяти компьютера.\nЧтобы работать с данными в памяти компьютера, нужно придумать имя, по которому вы будете к ним обращаться. Это имя называют переменной, а данные — её значением:\n\n// объявление переменной и задание значения:\nstring text = \"Привет, я уже программа!\";\n\n// пример использования переменной:\ncout << text << endl;\n\nВ этой программе объявлена переменная с именем text. Но делается всё то же, что и в знакомом вам коде из второго урока:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ncout << \"Привет, я уже программа!\" << endl;\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nЕщё один способ вывести то же самое использует сразу две переменные:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nstring text_begin = \"Привет,\";\nstring text_end = \"я уже программа!\";\n\n// выводим обе переменные, не забывая пробел между ними:\ncout << text_begin << \" \" << text_end << endl;\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nСлово string, написанное перед именем переменной — это её тип. Он задаётся при первом упоминании, то есть объявлении переменной и не может меняться.\nstring используется для строковых переменных. Объявление переменной — отдельная команда, после неё нужна точка с запятой.\nПри использовании переменной тип string не пишется. Достаточно просто имени. Объявление переменной — это отдельная команда.\nИспользована переменная может быть практически в любом месте, например, при выводе, в формуле или для задания другой переменной.\nИмя переменной может быть любым, главное, чтобы оно:\n• состояло исключительно из латинских букв, цифр или знаков подчёркивания (_),\n• не начиналось с цифры,\n• не совпадало со встроенным в язык ключевым словом,\n• было уникальным.\nИмя, удовлетворяющее перечисленным критериям, называется идентификатором. А вот набор допустимых типов строго определён.\n\nВ курсе имена переменных будем писать строчными буквами. Это часть нашего style guide.\nНо есть правило ещё важнее — имя переменной придумывайте так, чтобы легко было догадаться, какие данные она хранит. Например, переменная с именем user_name хранит имя пользователя, а с именем user_age — его возраст. К сожалению, компилятор не сможет проверить соблюдение этого правила, поэтому программист должен проявлять ответственность сам.\n\nВ этом коде сразу же при создании переменной ей присвоено значение. Со значениями переменных можно выполнять две основных операции — чтение и запись.\nПри чтении вы просто пишете имя переменной, как это сделано в команде: cout << text << endl;. Читать переменную можно сколько угодно раз, значение при этом не меняется.\nЗапись нового значения в переменную делается операцией присваивания. Первое присваивание, выполняемое прямо в команде объявления, называется «инициализация».\n\n// Объявляем переменную и сразу инициализируем её строкой:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nstring text = \"Привет, я уже программа!\";\ncout << text << endl;\n// Записываем в переменную новое значение, стирая старое.\n// Значение переменной text изменяется на строку \"Как ваши дела?\"\ntext = \"Как ваши дела?\";\ncout << text << endl;\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nРезультат:\nПривет, я уже программа!\nКак ваши дела?\n\nСмысл выражения x = y не такой как в математике. Операция присваивания — это команда заменить значение переменной x на значение y.\n\nЧтобы проверить, равны ли два значения, используют операцию ==, но об этом позже.\n\nCуществуют переменные, для которых доступно только чтение, но не запись. Они называются константными.\n\nПеременные могут использоваться для того, чтобы не повторять одно и то же выражение многократно:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nstring name = \"Бенедикт Хант\";\ncout << \"- Здравствуйте, меня зовут \" << name << \"!\" << endl;\ncout << \"Посмотрите пожалуйста почту на имя \" << name << \".\" << endl;\ncout << \"- На имя \" << name << \" имеются три письма!\" << endl;\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nРезультат:\n- Здравствуйте, меня зовут Бенедикт Хант!\nПосмотрите пожалуйста почту на имя Бенедикт Хант.\n- На имя Бенедикт Хант имеются три письма!\n\nМы не просто сократили написание, но получили возможность менять имя персонажа, переписывая всего лишь одну строчку кода. Так мы не рискуем допустить ошибку,\nзабыв поменять имя в одном из мест его использования:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n// Изменена только одна строчка кода:\nstring name = \"Роберт Райт\";\ncout << \"- Здравствуйте, меня зовут \" << name << \"!\" << endl;\ncout << \"Посмотрите пожалуйста почту на имя \" << name << \".\" << endl;\ncout << \"- На имя \" << name << \" имеются три письма!\" << endl;\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nРезультат:\n- Здравствуйте, меня зовут Роберт Райт!\nПосмотрите пожалуйста почту на имя Роберт Райт.\n- На имя Роберт Райт имеются три письма!",
    "isLock": true
  },
  {
    "id": 68,
    "language": "CPlusPlus",
    "title": "Урок 8. Числа",
    "text": "Компьютер в переводе с английского — это вычислитель. Большинство работы происходит с числами. Даже строки — всего лишь абстракция, \nведь каждый символ — некоторое число в памяти компьютера. В C++, разумеется, есть средства для работы с числами. Давайте познакомимся с новым типом — int:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\nint answer = 42;\ncout << answer << endl;\n\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nРезультат:\n42\n\nint — целочисленный тип, то есть подходит для хранения целых чисел обоих знаков: положительных и отрицательных.\nСтандарт C++ не определяет, какие конкретно числа можно записать в переменную типа int. Но во всех популярных компиляторах это числа в диапазоне от -2³¹ до 2³¹ − 1, \nто есть примерно от минус двух миллиардов до двух миллиардов.\nЭтот диапазон обусловлен эффективностью — многие современные процессоры максимально эффективно обрабатывают целые числа в этом диапазоне.\n\nC++ можно использовать в качестве калькулятора. Формулы пишутся как в математике. Возможные операции:\n• + для сложения,\n• - для вычитания или изменения знака числа,\n• * для умножения,\n• / для деления,\n• % для взятия остатка от деления для положительных чисел,\n• ( и ) для определения порядка действий.\n\nНапример, вам нужно переправить на пароме 5 грузовиков с роботами, но вы сомневаетесь, что паром, грузоподъёмность которого 10000 кг, выдержит. \nМасса грузовика — 1200 кг, масса робота — 100 кг, один грузовик вмещает 8 роботов. Рассчитаем и выведем суммарную массу такой формулой:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ncout << 5 * (1200 + 100 * 8) << endl;\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nРезультат — 10000, паром должен выдержать. Однако запутаться в таком коде просто. Вернувшись к нему через неделю, вы, скорее всего, уже не будете помнить, \nкакое число что означает. Исправят ситуацию переменные:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nint number_of_trucks = 5; // number of trucks - англ. количество грузовиков\nint truck_weight = 1200; // truck weight - англ. вес грузовика\nint robot_weight = 100; // robot weight - англ. вес робота\nint robots_per_truck = 8; // robot per truck - англ. роботов на грузовик\nint total_weight = number_of_trucks * (truck_weight + robot_weight * robots_per_truck); // total weight - англ. суммарный вес\ncout << total_weight << endl;\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nПеременная помогла документировать код. В одном выражении можно свободно комбинировать числа и значения переменных. Слегка перепишем этот код:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ncout << 5 * (truck_weight + robot_weight * robots_per_truck) << endl;\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nНо лучше не лениться и называть каждое значение, чтобы оно не выглядело взятым с потолка.\nВ одном объявлении допускается задание нескольких переменных одного типа. Разные переменные следует разделять запятой. Их можно записать в одну или несколько строк:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nint number_of_trucks = 5, truck_weight = 1200, // ставим запятую, объявление продолжается\n    robot_weight = 100, robots_per_truck = 8; // завершаем точкой с запятой\n\nint total_weight = number_of_trucks * (truck_weight + robot_weight * robots_per_truck);\ncout << total_weight << endl;\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nПри записи нового значения все предыдущие забываются. Переменные не имеют истории, и узнать, что было в переменной раньше, нельзя. \nОднако можно использовать текущее значение для вычисления нового. Так бы начальнику цеха не пришлось бы суммировать количество вручную, и код стал бы прозрачнее:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nint production = 20; // значение в первый день\nproduction = production + 25;\nproduction = production + 15;\nproduction = production + 26;\n// выводим результат - 86\ncout << production << endl;\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nОперация увеличения значения настолько распространена, что для неё придумали специальное сокращение +=. Этот код можно упростить:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nint production = 20; // значение в первый день\nproduction += 25; // смысл команды - увеличить production на 25\nproduction += 15;\nproduction += 26;\n// выводим результат - 86\ncout << production << endl;\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nПодобным образом работают операции *=, -=, /= и даже %=.\n\nПодобная операция работает в три этапа: читает значение, совершает арифметическое действие и потом записывает результат.",
    "isLock": true
  },
  {
    "id": 69,
    "language": "CPlusPlus",
    "title": "Урок 9. Инициализировать или не инициализировать — вот в чём вопрос",
    "text": "При объявлении переменной мы инициализируем её, но это делать не обязательно. С переменными типа string проблем не будет. \nПо умолчанию в такой переменной окажется пустая строка:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n// задаём вопрос:\ncout << \"Куда ж несёшься ты?\" << endl;\nstring answer;\n// выводим ответ в кавычках:\ncout << \"Ответ: \\\"\" << answer << \"\\\"\" << endl;\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nВывод вполне ожидаемый — ответа нет:\n\nКуда ж несёшься ты?\nОтвет: \"\"\n\nТак же можно поступать и с переменными типа int. Объявлять переменную без инициализации имеет смысл, если вы присвоите значение позже:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n// объявляем переменную с инициализацией\nint x = 42;\n// объявляем без инициализации\nint y;\n// и присваиваем значение\ny = 42;\ncout << \"x = \" << x << endl;\ncout << \"y = \" << y << endl;\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nПеременные x и y в этом примере обработаны одинаково:\n\nx = 42\ny = 42\n\nНо давайте попробуем вывести y до присваивания значения:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n// объявляем переменную с инициализацией\nint x = 42;\n// объявляем без инициализации\nint y;\n// выводим значения переменных:\ncout << \"x = \"s << x << endl;\ncout << \"y = \"s << y << endl;\n// а после присваиваем значение\ny = 42;\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nПри попытке скомпилировать эту программу вы увидите предупреждение:\n\nmain.cpp: In function 'int main()':\nmain.cpp:40:20: warning: 'y' may be used uninitialized [-Wmaybe-uninitialized]\n   40 | cout << \"y = \"s << y << endl;\n\nОно говорит, что переменная y может быть неинициализирована в месте использования. Посмотрим теперь на вывод:\n\nx = 42\ny = 4198416\n\nДействительно, значение y странное. Откуда оно взялось, совершенно непонятно. Скажем больше: на его месте может быть абсолютно любое число.\n\nКак ни странно, но программа с ошибкой может иногда работать верно. И это самое опасное. В примере выше есть ошибка — забыли проинициализировать переменную. \nИзначальное её значение не определено. Разработчики ещё говорят, что в ней мусор. Раз значение переменной не определено, \nто не определено и всё дальнейшее поведение программы, которая это значение использует.\nВ sum изначально может быть любое значение, значит, возможно значение 0. В этом случае вам будет казаться, что с программой всё хорошо, она считает верно. \nВы отправите программу пользователю, и у него уже возникнет проблема. Найти причину подобной проблемы иногда очень сложно, \nведь в реальных программах могут быть сотни и тысячи переменных.\nИспользование неинициализированных переменных — опасная ошибка. Опасна она в первую очередь тем, что часто кажется, будто всё работает хорошо. \nА на другом компьютере программа начинает творить странные вещи. Компилятор хоть и пытается предупредить вас, но в запутанных случаях он не сможет этого сделать.\nБудьте внимательны при работе с переменными!",
    "isLock": true
  },
  {
    "id": 70,
    "language": "CPlusPlus",
    "title": "Урок 10. Запятые тоже любят плавать",
    "text": "Вы много умножали и складывали числа, и это хорошо. Но давайте попробуем поделить. Например, на дне рождения у вас 3 торта на 5 человек.\nВы хотите узнать, по какой части торта должно достаться каждому, если разделить торты поровну:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nint number_of_cakes = 3;\nint number_of_throats = 5;\ncout << \"Количество тортов на человека: \" << (number_of_cakes / number_of_throats) << endl;\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nЗапускаем и смотрим, что вывела программа:\nКоличество тортов на человека: 0\n\nРезультат не впечатляет. Дело в том, что результатом деления целых чисел будет также целое число. C++ округляет результат, причём всегда в сторону нуля.\nДело тут не в жадности компилятора — такой подход упрощает многие целочисленные алгоритмы.\n\nПлавающие запятые\nНо алгоритмы алгоритмами, а торта всё-таки хочется. Гости вот-вот взбунтуются против сурового вердикта программы.\nИ вы понимаете, что целыми числами тут не обойтись, нужен новый тип. И такой тип есть, даже два:\n\n• float — от английского floating point number,\n• double — число с плавающей запятой двойной точности.\n\nВ курсе мы будем пользоваться в основном типом double, потому что он обеспечивает более точные вычисления.\nЗаменим в нашей программе int на double:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ndouble number_of_cakes = 3;\ndouble number_of_throats = 5;\ncout << \"Количество тортов на человека: \" << (number_of_cakes / number_of_throats) << endl;\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nНа этот раз результат обрадовал гостей гораздо больше:\nКоличество тортов на человека: 0.6\n\nТочность вывода\nВ английском языке «плавают» не запятые, а точки, поэтому для записи числа double в коде программы целую часть от дробной нужно отделять точкой.\nПопробуем посчитать стоимость 9999 роботов RC, каждый из которых стоит 999.99 фунтов:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ndouble rc21_cost = 999.99;\ncout << \"Cost of 9999 RCs: \"s << 9999 * rc21_cost << endl;\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nРезультат:\nCost of 9999 RCs: 9.9989e+06\n\nПолучилась не цена, а какая-то абракадабра. На самом деле, C++ посчитал правильно, но вот вывел в специальном научном формате.\nТакая запись означает, что точку в числе 9.9989 нужно подвинуть на шесть знаков вправо. Получится 9998900.\nИстинное значение, хранящееся в переменной, может отличаться от того, что выведено на экран. И даже от того, что вы написали в коде при задании переменной.\n\nОдно и то же число можно вывести разными способами. Используйте манипуляторы, чтобы изменить формат вывода чисел:\n\n• fixed — переключает режим вывода с научного на обычный,\n• setprecision — устанавливает количество знаков после запятой.\n\nВ скобках после setprecision указывается нужная нам точность. Для цены будем выводить два знака:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ndouble rc21_cost = 999.99;\ncout << \"Cost of 9999 RCs: \" << fixed << setprecision(2) << 9999 * rc21_cost << endl;\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nВывод теперь можно помещать на витрину магазина:\nCost of 9999 RCs: 9998900.01\n\n...\n(Остальной текст в таком же формате, заменяя все переносы строк на \\n)\n...",
    "isLock": true
  },
  {
    "id": 71,
    "language": "CPlusPlus",
    "title": "Урок 11. Ввод данных",
    "text": "До сих пор ваши программы работали по строго написанному сценарию и каждый раз выводили одно и то же. Но вряд ли какая-нибудь настоящая программа будет так делать.\nПользователь хочет быть не только наблюдателем, а участником и влиять на ход выполнения.\nДля этого, помимо стандартного вывода, предусмотрен стандартный ввод — поток, через который программа может получить информацию от пользователя.\nЕсли стандартный вывод — это cout, то стандартный ввод — cin. Для вывода мы направляем данные в поток операцией <<, а для ввода забираем данные из потока операцией >>.\nЧтобы хранить введённые пользователем данные, идеально подходят переменные:\n\nstring name;\nint age;\nint birth_year;\ncout << \"Введите имя, возраст, год рождения:\" << endl;\ncin >> name >> age;\ncin >> birth_year;\ncout << name << \" будет праздновать \" << age << \"-летие в \" << (birth_year + age) << \" году\" << endl;\n\nПрограмма выведет текст \"Введите имя, возраст, год рождения:\" и будет ждать, пока пользователь не наберёт что-нибудь типа John 50 1908 и не нажмёт Enter. Затем будет выведен текст:\nJohn будет праздновать 50-летие в 1958 году.\n\nПри вводе в переменную типа string будет читаться одно слово — до пробела или перевода строки. При вводе в переменную типа int или double будет браться одно число.\nЕсли при запросе в int пользователь введёт не цифры, поток перейдёт в состояние ошибки и больше ничего не будет читать.\n\nЗадание 1\nРазработайте калькулятор. Он должен читать два числа double и выполнять над ними следующие операции:\n• сложение,\n• вычитание,\n• умножение,\n• деление.\nРезультаты выводятся на экран.\nДо ввода из cin объявите две переменные типа double, в которые вы будете считывать.\n\nФормат выходных данных\nНужно вывести фразу \"Enter x and y:\". Она уже написана в заготовке. Затем запрашиваются два числа и выводятся следующие строки:\n• x + y = результат сложения,\n• x - y = результат вычитания,\n• x * y = результат умножения,\n• x / y = результат деления.\n\nМенять формат чисел не нужно.\nКак обычно, каждый вывод должен заканчиваться переводом строки.\n\nФормат входных данных\nЗапросите числа x и y типа double через cin.\n\nПример\nПрограмма вывела:\nEnter x and y:\nПользователь ввёл:\n10 5\nПрограмма вывела:\nx + y = 15\nx - y = 5\nx * y = 50\nx / y = 2\n\nПрограмма вывела:\nEnter x and y:\nПользователь ввёл:\n42 15\nПрограмма вывела:\nx + y = 57\nx - y = 27\nx * y = 630\nx / y = 2.8\n\nСкопируйте заготовку в онлайн-компилятор и выполните задание. Удачи!\n\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    cout << \"Enter x and y:\" << endl;\n    // ваш код здесь:\n    return 0;\n}",
    "isLock": true
  },
  {
    "id": 72,
    "language": "CPlusPlus",
    "title": "Урок 12. Суммируем всё на свете",
    "text": "Арифметические операции универсальны. Они сами выбирают, какой тип должен получиться в результате. Если вы складываете целые числа, получится целое число.\nА если складываете числа double, получится double:\n\n// настроим вывод\ncout << fixed << setprecision(2);\nint rc_21_count = 100;\nint rc_22_count = 18;\ncout << \"Total count: \" << (rc_21_count + rc_22_count) << endl;\n// ноль после точки можно опускать\ndouble rc_21_cost = 999.;\ndouble rc_22_cost = 1099.;\ncout << \"Total cost: \" << (rc_21_cost + rc_22_cost) << endl;\n\nВывод:\nTotal count: 118\nTotal cost: 2098.00\n\nЧтобы отличать целые числа от double, формат вывода настроен манипуляторами fixed и setprecision. Благодаря этому мы понимаем: Total count — это целое число,\nпоскольку в записи нет точки, Total cost — число double, так как в записи есть точка.\nЕсли арифметическая операция применяется к числам разных типов — к целому и числу с плавающей точкой, — результатом будет число с плавающей точкой:\n\n// настроим вывод\ncout << fixed << setprecision(2);\ndouble rc_23_cost = 1199.20;\ncout << \"Cost of 5 RCs: \" << 5 * rc_23_cost << endl;\n\nВывод:\nCost of 5 RCs: 5996.00\n\nНесмотря на то, что фактически получилось целое число, результат остаётся double. В C++ есть важное правило: все типы вычисляет компилятор, и делается это на этапе компиляции.\nТип выражения не может зависеть от того, какие конкретно значения оказались в переменных во время выполнения. Он зависит только от типов этих переменных.\nИными словами, 10.0 — это значение типа double, несмотря на то, что фактически оно целое, а \"100\" — имеет тип string, хотя в строке находится число.\nОказывается, складывать можно не только числа, но и строки:\n\nstring word1 = \"Hello\";\nstring word2 = \"C++\";\nstring space = \" \";\n// суммируем три строки\nstring text = word1 + space + word2;\ncout << text << endl;\n\nВывод:\nHello C++\n\nВ случае значений string знак плюс означает конкатенацию — приписывание одной строки к другой.\n\nКомпилятор выбирает, какое сложение использовать, только на основании типов складываемых значений. В этом случае складываются значения string, а значит, будет выбрана конкатенация.\nДля такого поведения есть веская причина. Но попробуйте сами ответить, в чём она состоит.\n\nТак вы узнали о четырёх ликах простого знака +:\n• + для int,\n• + для double,\n• + для float,\n• + для string.",
    "isLock": true
  },
  {
    "id": 73,
    "language": "CPlusPlus",
    "title": "Урок 13. Если и только если",
    "text": "Бывает, что программа должна выполнять некоторые действия не всегда, а лишь при определённых условиях. Например: делить числа, только если знаменатель не равен нулю;\nотправить робота на базу, только если спасены все пострадавшие; открыть окно настроек, только если пользователь в игре нажал на соответствующую кнопку.\nКомпьютер выполняет команды вашей программы последовательно. В предыдущих уроках вы не могли влиять на то, какие команды выполнятся, не меняя код. В C++ есть условный оператор if,\nкоторый позволяет исполнять или пропускать команды в зависимости от условия. Оно вычисляется уже во время работы программы.\nРассмотрим программу, которая выводит сумму, разность, произведение, частное и остаток от деления двух целых чисел. Деление целого числа на ноль в C++ приведёт к ошибке, поэтому частное и остаток можно вычислить, только если делитель не равен нулю:\n\nint x, y;\ncin >> x >> y;\ncout << \"x + y = \"s << x + y << endl;\ncout << \"x - y = \"s << x - y << endl;\ncout << \"x * y = \"s << x * y << endl;\n// Операция != читается как \"не равно\".\n// Всё вместе - \"если y не равно 0\".\nif (y != 0) {\n    cout << \"x / y = \"s << x / y << endl;\n    cout << \"x % y = \"s << x % y << endl;\n} \n\nВ круглых скобках после слова if пишется условие, при котором нужно выполнить команды, затем в фигурных скобках — сами команды.\nЕсли ввести числа 10 и 0, в выводе будут только три строки:\n\nx + y = 10;\nx - y = 10;\nx * y = 0;\n\nЕсли числа 8 и 3, то пять строк:\n\nx + y = 11;\nx - y = 5;\nx * y = 24;\nx / y = 2;\nx % y = 2;\n\nВ фигурных скобках пишутся самые обычные команды, с которыми вы уже знакомы. В круглых — условие, то есть булево выражение.\nСамый простой вид условий — сравнение. Всего существуют шесть операций сравнения:\n\n• > больше;\n• >= больше либо равно;\n• < меньше;\n• <= меньше либо равно;\n• == равно;\n• != не равно.\n\nКстати, сравнивать можно не только целые числа, но и числа double и даже строки между собой:\n\nstring password;\ncout << \"Введите пароль:\" << endl;\ncin >> password;\nif (password == \"bumpy\") {\n    cout << \"Доступ предоставлен\" << endl;\n\n    // выполним команду предоставления доступа\n    GiveAccess();\n} \n\nНовички часто путают операцию присваивания = и сравнения ==, а компилятор не всегда выдаёт ошибку при этом.\nБудьте внимательны и всегда пишите ==, когда хотите проверить, равны ли два значения.\n\nЗадание 1\nКогда охранник ночного клуба Роберт на работе, с детьми сидит его жена. Однако сегодня вечером ей нужно срочно уехать. Роберт решает остаться дома с детьми,\nно кто-то должен стоять на входе в клуб. Задача простая: пропускать только совершеннолетних. С ней прекрасно справится и RS-99, надо только обновить его программное обеспечение.\nНапишите программу, заменяющую охранника. Робот должен спросить \"How old are you?\". Затем он считывает целое число — возраст посетителя.\nЕсли посетителю есть 18, робот печатает приветствие: “Welcome!”.\n\nФормат входных данных\nЗапросите одно целое число — возраст.\n\nФормат выходных данных\n\n• Выведите текст How old are you?.\n• После считывания возраста выведите текст Welcome!, только если возраст не меньше 18.\n• Не забывайте endl в конце всех выводов.\n\nПример\nПрограмма вывела:\nHow old are you? \nПользователь ввёл:\n23 \nПрограмма вывела\nWelcome! \n\nПрограмма вывела\nHow old are you? \nПользователь ввёл\n17 \nПрограмма ничего не вывела\n\nЗаготовка:\n---------------------\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    //ваш код здесь:\n\n    return 0;\n}\n---------------------",
    "isLock": true
  },
  {
    "id": 74,
    "language": "CPlusPlus",
    "title": "Урок 14. else и else if",
    "text": "Зачастую нужно не просто выполнить определённые команды при определённом условии, но выполнить другие, если условие ложно. Это можно сделать дополнительным if:\n\nint x, y;\ncin >> x >> y;\ncout << \"x + y = \" << x + y << endl;\ncout << \"x - y = \" << x - y << endl;\ncout << \"x * y = \" << x * y << endl;\nif (y != 0) {\n    cout << \"x / y = \" << x / y << endl;\n    cout << \"x % y = \" << x % y << endl;\n}\nif (y == 0) {\n    cout << \"Деление не определено: знаменатель равен нулю\" << endl;\n} \n\nСитуация настолько частая, что в if предусмотрен дополнительный блок — else. Он позволяет переписать тот же код проще:\n\nint x, y;\ncin >> x >> y;\ncout << \"x + y = \" << x + y << endl;\ncout << \"x - y = \" << x - y << endl;\ncout << \"x * y = \" << x * y << endl;\nif (y != 0) {\n    cout << \"x / y = \" << x / y << endl;\n    cout << \"x % y = \" << x % y << endl;\n} else {\n    cout << \"Деление не определено: знаменатель равен нулю\" << endl;\n} \n\nКроме того, при выполнении не придётся проверять условие лишний раз. Ещё пример:\n\nstring password;\ncout << \"Введите пароль:\" << endl;\ncin >> password;\nif (password == \"bumpy\") {\n    cout << \"Доступ предоставлен\" << endl;\n    // выполним команду предоставления доступа\n    GiveAccess();\n} else {\n    cout << \"Пароль неправильный\" << endl;\n} \n\nЕсли вы скомпилируете эту программу и отправите её пользователю, он не сможет увидеть её код. Но есть способы разобраться, как работает даже скомпилированная программа,\nи скорректировать её поведение. Этот процесс называется reverse engineering. Программу выше нельзя называть защищённой.\n\nЕсли команды внутри первого if изменят значение переменной x, обе конструкции if выполнят свои команды. При реализации того же кода через else вы получаете гарантию,\nчто выполнится ровно один блок. Даже если условие стало ложным в процессе выполнения команд из if, ветка else не выполнится:\n\nint x;\ncin >> x;\n// будет выполнена только одна ветка, вне зависимости от того,\n// какие команды находятся внутри if и else\nif (x == 0) {\n    cout << \"Zero\" << endl;\n    // какие-то команды\n    ............\n} else {\n    cout << \"Not zero\" << endl;\n    // какие-то команды\n    ............\n} \n\nЕсли вам нужно разобрать сразу много случаев, можно использовать конструкцию else if, после которой пишется дополнительное условие:\n\nif (angle > 90) {\n    cout << \"Тупой угол\" << endl;\n} else if (angle == 90) {\n    cout << \"Прямой угол\" << endl;\n} else {\n    cout << \"Острый угол\" << endl;\n} \n\nКоличество else if в одной условной конструкции не ограничено. Но будут выполнены команды только одной ветки — у первой, где условие оказалось верным.\nЕсли все условия конструкции ложные, будет выполнена ветка else, а если её нет — ничего.\n\nЗадание 1\nРазработайте калькулятор, который будет вычислять одну из заданных операций:\n\n• сложение (+),\n• вычитание (-),\n• умножение (*),\n• деление (/).\n\nЧерез cin нужно считать оба числа и операцию.\n\nФормат входных данных\n\nСчитайте следующие данные:\n\n• double — первое число,\n• string — знак операции,\n• double — второе число.\n\nФормат выходных данных\n\n• Если операция не равна ни одной из четырёх допустимых, выведите текст Unknown operation:, затем пробел и прочитанную операцию.\n• Если запрошено деление, но второе число равно нулю, выведите текст Division by zero.\n• В остальных случаях выведите знак = и результат через пробел.\n\nПример\nПользователь ввёл\n  12.13 * 14.15 \nПрограмма вывела\n  = 171.64\n\nПользователь ввёл\n  355 / 113  \nПрограмма вывела\n  = 3.14159\n\nПользователь ввёл\n  12 aaa 44\nПрограмма вывела\n  Unknown operation: aaa\n\nПользователь ввёл\n  10 / 0\nПрограмма вывела\n  Division by zero\n\nЗаготовка:\n\n#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main()\n{\n    //объявите и инцилизируйте переменные\n    if(...){\n        //ваш код здесь\n    } //продумайте дальнейшие ветвления\n\n    return 0;\n}",
    "isLock": true
  },
  {
    "id": 75,
    "language": "CPlusPlus",
    "title": "Урок 15. Всё, что объявлено внутри фигурных скобок, остаётся внутри фигурных скобок",
    "text": "Рассмотрим программу, которая выводит имя секретного агента по его кодовому номеру:\n\nint agent_number;\ncin >> agent_number;\n\nif (agent_number == 5) {\n    string name = \"Stuart Thomas\";\n} else if (agent_number == 6) {\n    string name = \"Major Jack Giddings\";\n} else if (agent_number == 7) {\n    string name = \"James Bond\";\n} else {\n    string name = \"Unknown\";\n}\n\n// При компиляции возникнет ошибка\ncout << \"00\" << agent_number << \"-agent name: \" << name << endl;\n\nСобрать эту программу не получится, при компиляции возникнет ошибка: 'name' was not declared in this scope. Дело в том, что в C++ есть важное правило:\nВсё, что объявлено внутри фигурных скобок, остаётся внутри фигурных скобок.\nНа самом деле мы объявили целых четыре переменных name, и это разные переменные. Ни одна из них не видна в момент вывода информации об агенте.\nЧтобы исправить программу, нужно объявить переменную вне скобок. Внутри if присвоим ей значение:\n\nint agent_number;\ncin >> agent_number;\n\nstring name;\n\nif (agent_number == 5) {\n    name = \"Stuart Thomas\";\n} else if (agent_number == 6) {\n    name = \"Major Jack Giddings\";\n} else if (agent_number == 7) {\n    name = \"James Bond\";\n} else {\n    name = \"Unknown\";\n}\n\n// Вместо нескольких команд используем одну:\ncmp; cout << \"00\" << agent_number << \"-agent name: \" << name << endl;\n\nТеперь программа скомпилируется. Введём 7 и получим ответ:\n\n007-agent name: James Bond\n\nОбъявление переменной — это первое её упоминание с указанием типа. Внутри if выполняется присваивание уже объявленной переменной.\n\nТаким образом, в одной программе может быть несколько переменных, называемых совершенно одинаково. Это возможно, если они находятся в разных областях видимости — частях кода,\nограниченных фигурными скобками. С точки зрения компилятора, эти переменные никак друг с другом не связаны, как если бы они назывались по-разному.",
    "isLock": true
  },
  {
    "id": 76,
    "language": "CPlusPlus",
    "title": "Урок 16. Ставим условия",
    "text": "Пришло время изучить условия более подробно. Они не ограничиваются операциями сравнения. Условия можно комбинировать и даже сохранять их значения в переменные.\nДля этого понадобится специальный тип bool, который принимает только два значения: true или false. Переменная этого типа называется «логическая переменная» или «булевая переменная».\nРассмотрим программу с if, которая проверяет возраст посетителя клуба:\n\ncout << \"Сколько вам лет?\" << endl;\nint age;\ncin >> age;\nif (age < 18) {\n    cout << \"К сожалению, вам нельзя в наш клуб\" << endl;\n}\n\nЕё можно переписать:\n\ncout << \"Сколько вам лет?\" << endl;\nint age;\ncin >> age;\n// вычислим условие и сохраним его значение в переменную:\nbool is_infant = age < 18;\nif (is_infant) {\n    cout << \"К сожалению, вам нельзя в наш клуб\" << endl;\n}\n\nОператор if принимает условие и выполняет команды, если оно true.\n\nНапишем программу, которая вычисляет угол треугольника:\n\ncout << \"Введите два угла треугольника:\" << endl;\ndouble alpha, beta, gamma;\ncin >> alpha >> beta;\n// вычислим третий угол:\ngamma = 180. - alpha - beta;\ncout << \"Третий угол: \" << gamma << endl;\n\nА теперь добавим в неё определение типа треугольника: если хотя бы один угол тупой, мы хотим написать, что треугольник тупоугольный. Дополним уже написанный код и решим задачу так:\n\nif (alpha > 90) {\n    cout << \"Треугольник тупоугольный\" << endl;\n}\nif (beta > 90) {\n    cout << \"Треугольник тупоугольный\" << endl;\n}\nif (gamma > 90) {\n    cout << \"Треугольник тупоугольный\" << endl;\n}\n\nРешение выглядит не очень: фразу пришлось повторить три раза. Условие, которое мы хотим проверить: «‎Угол α больше 90 или угол β больше 90, или угол γ больше 90».\nВ C++ оно записывается с операцией ‎логическое «ИЛИ». Её обозначают символами ||:\n\nif (alpha > 90 || beta > 90 || gamma > 90) {\n    cout << \"Треугольник тупоугольный\" << endl;\n}\n\nТеперь проверим, что треугольник остроугольный, то есть все его углы меньше 90. Проверим условие «‎угол α меньше 90 и угол β меньше 90, и угол γ меньше 90»:\n\nif (alpha < 90 && beta < 90 && gamma < 90) {\n    cout << \"Треугольник остроугольный\" << endl;\n} \n\nТеперь объединим всё в одну конструкцию и получим полный классификатор треугольников:\n\nif (alpha > 90 || beta > 90 || gamma > 90) {\n    cout << \"Треугольник тупоугольный\" << endl;\n} else if (alpha < 90 && beta < 90 && gamma < 90) {\n    cout << \"Треугольник остроугольный\" << endl;\n} else {\n    cout << \"Треугольник прямоугольный\" << endl;\n}\n\nПоследняя важная логическая операция — отрицание. Эта операция применяется к логическому выражению: истинные выражения она превращает в ложные и наоборот.\nОперация обозначается знаком !. Его ставят перед условием, которое нужно обратить:\n\ncout << \"Сколько вам лет?\" << endl;\nint age;\ncin >> age;\n\nbool is_infant = age < 18;\nif (!is_infant) {\n    cout << \"Добро пожаловать!\" << endl;\n}\n\nВ этом примере операция ! применена к выражению, состоящему из одной переменной. Вывод выполнится, только если значение переменной is_infant ложно.\n\nЗадание 2\nПорядковые числительные по-английски обозначаются так:\n• первый — 1st,\n• второй — 2nd,\n• третий — 3rd,\n• четвёртый — 4th,\n• пятый — 5th,\n• 101-й — 101st,\n• 102-й — 102nd,\n• 103-й — 103rd,\n• 104-й — 104th,\n• 105-й — 105th.\nОбщее правило: если число заканчивается на 1, ставят суффикс “st”, если на 2 — “nd”, если на 3 — “rd”, а в остальных случаях — “th”. Исключение составляют числа, которые оканчиваются на 11, 12 и 13. Для них используют суффикс “th”.\nНапишите программу, которая запрашивает целое число и печатает английское порядковое числительное.\nЧтобы вычислить последнюю цифру, можно использовать операцию взятия остатка: выражение x % 10 будет равно последней цифре числа x. Учтите, что если x — отрицательное число, то и цифра будет со знаком минус. Чтобы узнать две последние цифры, напишите x % 100.\nЭто непростая задача, но к ней даны подробные подсказки. Постарайтесь решить её самостоятельно, прежде чем заглядывать в них.\nЧтобы упростить решение, можно использовать функцию abs. Она убирает знак числа, делая отрицательное число положительным. Она применяется аналогично другим математическим функциям, но работает с целыми числами: int y = abs(x);\n\nФормат входных данных\nСчитайте целое число int. Переменная уже объявлена в заготовке.\n\nФормат выходных данных\nВыведите считанное число с подходящим суффиксом.\n\nТребования\n• Программа должна корректно обрабатывать как положительные, так и отрицательные числа. Ноль тоже должен быть обработан корректно.\n• В готовом решении не выводите ничего лишнего.\n\nПримеры\n• 0th\n• 1st\n• 11th\n• 21st\n• 1010102nd\n• -10th\n• -11th\n• -3333333rd\n\nЗаготовка:\n\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main()\n{\n    //ваш код здесь:\n    return 0;\n}",
    "isLock": true
  },
  {
    "id": 77,
    "language": "CPlusPlus",
    "title": "Урок 17. Храним по-новому: vector",
    "text": "Вы изучили простые типы данных, которые могут хранить только одно значение:\n• int — для целых чисел,\n• double и float — для чисел с плавающей точкой,\n• string — для строк,\n• bool — для логических значений.\nНо есть более сложные типы, которые могут хранить сразу несколько значений. Одному из таких типов, vector, посвящён сегодняшний урок.\n\nПеременная типа vector предназначена для хранения набора значений другого типа, например строк. Такой объект в программировании называется «контейнер». Он действительно похож на контейнер, поскольку способен вмещать множество других объектов. Значения перечисляются в фигурных скобках при создании переменной:\nvector holmes_friends = {\"Доктор Ватсон\", \"Миссис Хадсон\",\n                         \"Майкрофт Холмс\", \"Инспектор Лестрейд\"};\n\nКоличество значений в векторе называется его размером, а сами значения — элементами. Выше создан вектор размера четыре. Нумеруются элементы с нуля:\n• 0 — \"Доктор Ватсон\",\n• 1 — \"Миссис Хадсон\",\n• 2 — \"Майкрофт Холмс\",\n• 3 — \"Инспектор Лестрейд\".\nНомер элемента в векторе называют индексом.\n\nЭлементы вектора нумеруются с нуля. Поэтому индекс последнего элемента будет всегда на единицу меньше, чем размер вектора.\n\nНазвание типа vector происходит из математики. Математические векторы в линейных пространствах можно задать набором чисел. Однако разработчик стандартной библиотеки C++ Александр Степанов впоследствии признавался, что название выбрано ошибочно — в математике вектор имеет строго определённое количество компонент, а в C++ размер вектора может меняться.\nВектор может хранить значения любого другого типа. Прекрасно подойдут и числа:\n\nvector prime_numbers_before_20 = {2, 3, 5, 7, 11, 13, 17, 19};\nvector squares_before_30 = {1 * 1, 2 * 2, 3 * 3, 4 * 4, 5 * 5};\n\nМожно даже создать вектор из одного значения:\n\nvector pi_names = {\"pi\"s};\nvector pi_values = {4 * atan(1.)};\n\nНо нельзя сохранять в векторе значения разных типов:\n\n// ошибка: разные типы в векторе\nvector err = {\"number\"s, 13};\n\nХранить что-то, если это нельзя прочитать, нет смысла. Поэтому для вектора предусмотрена операция доступа к его элементам. Чтобы прочитать элемент вектора по индексу, нужно записать этот индекс в квадратных скобках после обозначения самого вектора. Использовать полученное значение можно для вычисления, вывода, сохранения в переменную, в условии if или любом другом выражении:\n\nvector alphabet = {\n    \"а\"s, \"б\"s, \"в\"s, \"г\"s, \"д\"s, \"е\"s, \"ё\"s, \"ж\"s, \"з\"s,\n    \"и\"s, \"й\"s, \"к\"s, \"л\"s, \"м\"s, \"н\"s, \"о\"s, \"п\"s, \"р\"s,\n    \"с\"s, \"т\"s, \"у\"s, \"ф\"s, \"х\"s, \"ц\"s, \"ч\"s, \"ш\"s, \"щ\"s,\n    \"ъ\"s, \"ы\"s, \"ь\"s, \"э\"s, \"ю\"s, \"я\"s};\n\n// Напечатать элемент с индексом 1\ncout << alphabet[1] << endl;\n\n// Элемент с индексом 2 напечатаем другим способом:\n// вначале сохраним его из вектора в переменную.\nstring letter = alphabet[2];\ncout << letter << endl;\n\nБуква «a» имеет индекс ноль и не будет выведена. Вероятно, поначалу будет трудно смириться с этой особенностью вектора, но практика поможет привыкнуть.\nПри использовании квадратных скобок индекс элемента не должен выходить за допустимые пределы. Корректный индекс больше либо равен нулю и строго меньше размера вектора. Иначе поведение программы будет неопределённым. Неопределённому поведению будут посвящены отдельные уроки курса.\nОперация [] позволяет не только получать значение элемента, но и менять его так же, как обычные переменные:\n\nvector book_heroes = {\"Остап Бендер\", \"Александр Корейко\",\n                      \"Зося Синицкая\"};\n\n// Изменяем нулевой элемент вектора:\nbook_heroes[0] = \"Остап Бендер-Задунайский\";\n\n// Изменяем второй элемент вектора:\nbook_heroes[2] = \"Зося Синицкая-Фемиди\";\n\ncout << book_heroes[0] << endl;\ncout << book_heroes[1] << endl;\ncout << book_heroes[2] << endl;\n\nВывод:\nОстап Бендер-Задунайский\nАлександр Корейко\nЗося Синицкая-Фемиди\n\nЗадание 1\n\nСоздайте вектор целых чисел, состоящий из чётных чисел от 10 до 20, включая крайние значения. Переменную назовите even.\n\nТребования\n• Программа не должна ничего выводить в поток вывода.\n• Название переменной должно быть even.\n• Числа в векторе должны идти в порядке возрастания и не повторяться.\n\nЗаготовка:\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n    //ваш код здесь\n\n    return 0;\n}",
    "isLock": true
  },
  {
    "id": 78,
    "language": "CPlusPlus",
    "title": "Урок 18. Продвинутый вектор",
    "text": "В прошлом уроке мы модифицировали содержимое вектора, присваивая элементам новые значения. В этом уроке вы узнаете, как вставлять и удалять из вектора элементы, меняя его размер.\nПомогут в этом методы — функции, выполняемые конкретным объектом. Также рассмотрим методы для получения размера и очистки вектора.\n\nМетоды вектора\nСамое простое — вставка элемента в конец вектора. Для этого используют метод push_back. Чтобы вставить элемент в конец вектора, после имени переменной, обозначающей вектор, пишут точку.\nЗатем указывают имя метода, а в скобках — вставляемый элемент:\n\nvector holmes_friends = {\"Доктор Ватсон\", \"Миссис Хадсон\",\n                         \"Майкрофт Холмс\", \"Инспектор Лестрейд\"};\n// Добавляем элемент в конец вектора.\n// После переменной ставим точку, далее в скобках\n// сам элемент - параметр метода.\nholmes_friends.push_back(\"Бэрримор\");\n// Новый элемент получил индекс 4\ncout << holmes_friends[4] << endl;\n\n// Будет выведено - Бэрримор\n\nМетод push_back модифицирует вектор. Есть методы для получения информации — например, для размера вектора в виде числа. Этот метод называется size.\nОн не имеет параметров, поэтому после имени метода пишутся пустые круглые скобки:\n\nvector holmes_friends = {\"Доктор Ватсон\", \"Миссис Хадсон\",\n                         \"Майкрофт Холмс\", \"Инспектор Лестрейд\"};\n\n// Будет выведена фраза \"Holmes has 4 friends\",\n// т. к. в векторе 4 элемента:\ncout << \"Holmes has \" << holmes_friends.size()\n     << \" friends\" << endl;\n\nholmes_friends.push_back(\"Бэрримор\");\n\n// Будет выведена фраза \"Holmes has 5 friends\":\ncout << \"Holmes has \" << holmes_friends.size() << \" friends\" << endl;\n\nУдалить элемент из конца вектора можно методом pop_back. Используется он так же, как push_back, но не имеет параметров. Не забывайте пустые круглые скобки после него:\n\nvector holmes_friends = {\"Доктор Ватсон\", \"Миссис Хадсон\",\n                         \"Майкрофт Холмс\", \"Инспектор Лестрейд\"};\n\n// Будет выведена фраза \"Holmes has 4 friends\",\ncout << \"Holmes has \" << holmes_friends.size() << \" friends\" << endl;\n\n// Удляем последний элемент вектора\nholmes_friends.pop_back();\n\n// Будет выведена фраза \"Holmes has 3 friends\":\ncout << \"Holmes has \" << holmes_friends.size() << \" friends\" << endl;\n\nПосле удаления инспектора из вектора останется три элемента: Доктор Ватсон, Миссис Хадсон и Майкрофт Холмс.\n\nПроблемы пустых векторов\nМожет появиться желание создать пустой вектор и добавить в него нужные элементы:\n\n// ошибка: невозможно определить тип элементов вектора\nvector holmes_friends = {};\n\nholmes_friends.push_back(\"Доктор Ватсон\");\nholmes_friends.push_back(\"Миссис Хадсон\");\nholmes_friends.push_back(\"Майкрофт Холмс\");\n\nПри этом возникнет ошибка: class template argument deduction failed. Она означает, что компилятор не смог определить тип элементов вектора.\nВ таком случае его нужно задать явно в угловых скобках:\n\n// задаём тип элементов вектора явно\nvector<string> holmes_friends = {};\n\nholmes_friends.push_back(\"Доктор Ватсон\");\nholmes_friends.push_back(\"Миссис Хадсон\");\nholmes_friends.push_back(\"Майкрофт Холмс\");\n\nВ этом примере указан полный тип переменной. В предыдущих примерах компилятор выводил его автоматически, исходя из того, какие элементы клались в вектор при объявлении переменной.\nПри создании пустого вектора конструкцию = {} можно опустить. Полный тип при этом указывать обязательно:\n\nvector<string> holmes_friends;\nholmes_friends.push_back(\"Доктор Ватсон\");\nholmes_friends.push_back(\"Миссис Хадсон\");\nholmes_friends.push_back(\"Майкрофт Холмс\");\n\nНе будет ошибкой и указание полного типа при инициализации со значениями. Главное, чтобы тип совпадал с типом значений.\n\n// Указываем полный тип, хотя могли бы этого не делать:\nvector<string> holmes_friends = {\"Доктор Ватсон\", \"Миссис Хадсон\", \"Майкрофт Холмс\"};\n\nНачинающему программисту лучше всегда указывать полный тип, даже когда этого можно не делать. Так вы предостережёте себя от запутанных ошибок,\nвозникших потому что компилятор вывел не тот тип, который вы хотели. Предлагаем вам всегда указывать полный тип вектора в подготовительном разделе.\n\nВектор в векторе\nЭлементами вектора могут быть значения любого типа. В том числе другие векторы:\n\n// Создадим таблицу умножения чисел от 0 до 5:\nvector<vector<int>> multiplication_table = {\n    {0 * 0, 0 * 1, 0 * 2, 0 * 3, 0 * 4, 0 * 5},\n    {1 * 0, 1 * 1, 1 * 2, 1 * 3, 1 * 4, 1 * 5},\n    {2 * 0, 2 * 1, 2 * 2, 2 * 3, 2 * 4, 2 * 5},\n    {3 * 0, 3 * 1, 3 * 2, 3 * 3, 3 * 4, 3 * 5},\n    {4 * 0, 4 * 1, 4 * 2, 4 * 3, 4 * 4, 4 * 5},\n    {5 * 0, 5 * 1, 5 * 2, 5 * 3, 5 * 4, 5 * 5}\n};\n\nmultiplication_table имеет тип vector<vector<int>>, значит, multiplication_table[2] имеет тип vector<int>. Чтобы получить доступ к элементу внутреннего вектора,\nнапишем квадратные скобки ещё раз:\n\nvector<vector<int>> multiplication_table = {\n    {0 * 0, 0 * 1, 0 * 2, 0 * 3, 0 * 4, 0 * 5},\n    {1 * 0, 1 * 1, 1 * 2, 1 * 3, 1 * 4, 1 * 5},\n    {2 * 0, 2 * 1, 2 * 2, 2 * 3, 2 * 4, 2 * 5},\n    {3 * 0, 3 * 1, 3 * 2, 3 * 3, 3 * 4, 3 * 5},\n    {4 * 0, 4 * 1, 4 * 2, 4 * 3, 4 * 4, 4 * 5},\n    {5 * 0, 5 * 1, 5 * 2, 5 * 3, 5 * 4, 5 * 5}\n};\n\ncout << \"2 * 3 = \"s << multiplication_table[2][3] << endl;",
    "isLock": true
  },
  {
    "id": 79,
    "language": "CPlusPlus",
    "title": "Урок 19. Ходим по кругу — цикл for",
    "text": "В жизни порой приходится многократно выполнять одно и то же действие. Скажем, вы хотите поздравить друзей с Новым годом. Отправление каждой открытки потребует повторения действий:\n\n• Взять открытку.\n• Написать поздравление.\n• Написать адрес.\n• Наклеить марку.\n• Опустить открытку в почтовый ящик.\n\nПовторять эти действия следует не бесконечно, а лишь до тех пор, пока в почтовом ящике не окажутся поздравления для всех адресатов.\nВ программировании есть конструкции для повторения действий — циклы.\n\nРассмотрим программу для поздравления:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nvector holmes_addressees = {\"Доктор Ватсон\", \"Миссис Хадсон\",\n                            \"Майкрофт Холмс\", \"Инспектор Лестрейд\"};\n\ncout << \"Начинаем печать открыток\" << endl;\n\ncout << \"Текст открытки:\" << endl;\ncout << \"С новым годом, \" << holmes_addressees[0] << \"!\" << endl;\ncout << endl;\n\ncout << \"Текст открытки:\" << endl;\ncout << \"С новым годом, \" << holmes_addressees[1] << \"!\" << endl;\ncout << endl;\n\ncout << \"Текст открытки:\" << endl;\ncout << \"С новым годом, \" << holmes_addressees[2] << \"!\" << endl;\ncout << endl;\n\ncout << \"Текст открытки:\" << endl;\ncout << \"С новым годом, \" << holmes_addressees[3] << \"!\" << endl;\ncout << endl;\n\ncout << \"Открытки закончились\" << endl;\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\nТакой код имеет массу недостатков:\n• Его трудно менять. Для изменения одной фразы её нужно редактировать сразу во всех местах.\n• Может нарушиться консистентность. В код со временем вносятся правки. Когда в нём повторяются одни и те же команды, рано или поздно, а скорее, рано вы внесёте правки в одну команду, а в другую — забудете. Блоки кода, которые должны быть одинаковыми, станут отличаться. Чем дальше, тем больше.\n• Трудно тестировать. Если код скопирован четыре раза, нужно убедиться, что все четыре копии работают правильно. Как вы знаете из предыдущего пункта, они могут отличаться.\n• Код подвержен ошибкам. Легко ошибиться с индексом и пропустить кого-то или отправить одному адресату два поздравления.\n• Наконец, он просто длинный и его трудно писать.\nЭтот код можно упростить циклом for:\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nvector holmes_addressees = {\"Доктор Ватсон\", \"Миссис Хадсон\",\n                            \"Майкрофт Холмс\", \"Инспектор Лестрейд\"};\n\ncout << \"Начинаем печать открыток\" << endl;\n\nfor (string addressee : holmes_addressees) {\n    cout << \"Текст открытки:\" << endl;\n    cout << \"С новым годом, \" << addressee << \"!\" << endl;\n    cout << endl;\n}\n\ncout << \"Открытки закончились\" << endl;\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\n...",
    "isLock": true
  }
]